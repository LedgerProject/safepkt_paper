\section{Semantics}\label{sec:semantics}

This section gives a formal definition of the types used by the borrow checker
of Rust and of the typing procedure for leftvalues defined in~\cite{Pearce21}.

\begin{definition}
  We assume there is a set of variables $\Vars$.
  A context $\kappa\subseteq\Vars$ is a finite set of variables in scope.
  The set $\Leftvalues_\kappa$ of \emph{leftvalues} over $\kappa$ is defined as:
  \begin{align*}
    \mathsf{w} ::= &\ x & \text{variable, with $x\in\kappa$}\\
    | &\ \mathtt{*}\mathsf{w} & \text{dereference.}
  \end{align*}
  The \emph{root} of a leftvalue is the starting variable to which the dereferences of the
  leftvalue are applied. Namely, we define
  \begin{align*}
    \mathsf{root}(x) &= x\qquad\text{if $x\in\Vars$}\\
    \mathsf{root}(\mathtt{*}\mathsf{w}) &= \mathsf{root}(\mathsf{w}).
  \end{align*}
\end{definition}

The types used by the borrow checker are somehow non-standard, in the sense
that they describe primitive types (such as \<int>) or structures
dynamically allocated in memory (collectively represented by a box), but can also refer to
a borrow or mutable borrow of one or more leftvalues.
Moreover, a type can state that a value has been \emph{moved}, that is, assigned
to another owner. Consequently, it exists but cannot be dereferenced.
We write this as \<dangling>. In comparison to~\cite{Pearce21}, we are using
a slight simplified set of types here, since~\cite{Pearce21} provides
the \emph{ghost} type $t$ of a value that has been moved, as $\<dangling>(t)$.
This information is important to ensure that a variable, whose value has been
previously moved away, is subsequently reassigned a value compatible
with its original type $t$. However, we abstract this detail here, since it is irrelevant for
the termination of the algorithm for typing leftvalues.

\begin{definition}[Types]
  The set of \emph{types} over a context $\kappa$ is
  \begin{align*}
    \mathsf{T}_\kappa ::=&\ \mathsf{int} & \text{integer}\\
    | &\ \borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} & \text{borrow}\\
    | &\ \mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} & \text{mutable borrow}\\
    | &\ \boxtype{\mathsf{T}_\kappa} & \text{box}\\
    | &\ \mathsf{dangling} & \text{dangling}
  \end{align*}
  where $n\ge 1$ and $\mathsf{w}_i\in\Leftvalues_\kappa$ for $1\le i\le n$.
  This set is ordered by $\sqsubseteq$, defined as
  \begin{align*}
    \mathsf{int}&\sqsubseteq\mathsf{int}\\
    \borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} & \sqsubseteq
    \borrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\} \quad\text{iff $\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}\subseteq\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\}$}\\
    \mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} & \sqsubseteq
    \mutborrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\} \quad\text{iff $\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}\subseteq\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\}$}\\
    \boxtype{t_1}&\sqsubseteq\boxtype{t_2} \quad\text{iff $t_1\sqsubseteq t_2$}\\
    \mathsf{dangling}&\sqsubseteq\mathsf{dangling.}
  \end{align*}
\end{definition}

\begin{lemma}
  \label{lemma:partial-order-types}
  $(\mathsf{T}_\kappa,\sqsubseteq)$ is a partially ordered set.
\end{lemma}
\begin{proof}
  We proceed by structural induction.
  \begin{itemize}
    \item (Reflexivity)
    \begin{itemize}
      \item (Base) For any type $t$ that is not a box we have
      $t\sqsubseteq t$.
      \item (Induction step) If $t\sqsubseteq t$ for a type $t$ then
      $\boxtype{t}\sqsubseteq \boxtype{t}$.
    \end{itemize}
    %
    \item (Antisymmetry) Suppose that $t_1 \sqsubseteq t_2$ and
    $t_2 \sqsubseteq t_1$.
    \begin{itemize}
      \item (Base: $t_1$ or $t_2$ is not a box)
      If $t_1$ or $t_2$ is $\mathsf{int}$, then so is the other
      because $\mathsf{int}$ can only be greater than itself, and so $t_1 = t_2$.
      Similarly if $t_1$ or $t_2$ is $\mathsf{dangling}$.
      If $t_1$ or $t_2$ is a borrow, then so is the other because
      a borrow can only precede a borrow, and so we have $t_1 = t_2$
      by antisymmetry of $\subseteq$.
      Similarly if $t_1$ or $t_2$ is a mutable borrow.
      \item (Induction step) Suppose that $t_1=\boxtype{t'_1}$ and
      $t_2=\boxtype{t'_2}$ for types $t'_1,t'_2$ such that
      $(t'_1 \sqsubseteq t'_2 \land t'_2 \sqsubseteq t'_1) \Rightarrow t'_1 = t'_2$.
      As $t_1 \sqsubseteq t_2$ and $t_2 \sqsubseteq t_1$, we have
      $t'_1 \sqsubseteq t'_2$ and $t'_2 \sqsubseteq t'_1$, so
      $t'_1 = t'_2$, hence $t_1 = t_2$.
    \end{itemize}
    %
    \item (Transitivity) Suppose that $t_1 \sqsubseteq t_2$ and $t_2 \sqsubseteq t_3$.
    \begin{itemize}
      \item (Base: $t_1$, $t_2$ or $t_3$ is not a box)
      If $t_1$, $t_2$ or $t_3$ is $\mathsf{int}$, we necessarily have
      $t_1=t_2=t_3=\mathsf{int}$ because $\mathsf{int}$ is only related to
      itself, and so $t_1\sqsubseteq t_3$. Similarly if
      $t_1$, $t_2$ or $t_3$ is $\mathsf{dangling}$.
      If $t_1$, $t_2$ or $t_3$ is a borrow, then so are the others because
      a borrow is only related to a borrow, and so we have
      $t_1\sqsubseteq t_3$ by transitivity of $\subseteq$.
      Similarly if $t_1$, $t_2$ or $t_3$ is a mutable borrow.
      \item (Induction step) Suppose that $t_1=\boxtype{t'_1}$,
      $t_2=\boxtype{t'_2}$ and $t_3=\boxtype{t'_3}$ for types
      $t'_1,t'_2,t'_3$ such that
      $(t'_1 \sqsubseteq t'_2 \land t'_2 \sqsubseteq t'_3) \Rightarrow
      t'_1 \sqsubseteq t'_3$.
      As $t_1 \sqsubseteq t_2$ and $t_2 \sqsubseteq t_3$, we have
      $t'_1 \sqsubseteq t'_2$ and $t'_2 \sqsubseteq t'_3$, so
      $t'_1 \sqsubseteq t'_3$, hence $t_1 \sqsubseteq t_3$.
    \end{itemize}
  \end{itemize}
  \qed
\end{proof}

%\begin{definition}
%  The $\sqcap$ operator over $\mathsf{T}_\kappa$ is defined as
%  \begin{align*}
%    \mathsf{int}\sqcap\mathsf{int} &= \mathsf{int}\\
%    \borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} \sqcap \borrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\} &= \borrow(\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}\cap\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\})\\
%    \mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} \sqcap \mutborrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\} &= \mutborrow(\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}\cap\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\})\\
%    (\boxtype{t_1}) \sqcap (\boxtype{t_2}) &=\boxtype{(t_1\sqcap t_2)}\quad\text{if $t_1\sqcap t_2$ is defined}\\
%    \mathsf{dangling}\sqcap\mathsf{dangling} &= \mathsf{dangling}.
%  \end{align*}
%  In all other cases, $t_1\sqcap t_2$ is undefined.
%\end{definition}

%\begin{lemma}\label{lemma:glb-type}
%  Let $I\subseteq\mathbb{N}$ and $\{t_i\}_{i\in I}\subseteq\mathsf{T}_\kappa$.
%  Then, if $\sqcap_{i\in I}t_i$ is defined, it is the greatest lower bound of $\{t_i\}_{i\in I}$.
%\end{lemma}
%\begin{proof}
%  Assume that $\mu_I = \sqcap_{i\in I}t_i$ is defined.
%  We proceed by structural induction.
%  \begin{itemize}
%    \item (Base: there is a $t_k$ which is not a box)
%    If $t_k=\mathsf{int}$ then, as $\mu_I$ is defined, for all $i\in I$
%    we have $t_i=\mathsf{int}$. Therefore, $\mu_I=\mathsf{int}$
%    and so $\mu_I$ is a lower bound of $\{t_i\}_{i\in I}$.
%    Similarly if $t_k=\mathsf{dangling}$.
%    If $t_k$ is a borrow then, for all $i\in I$, $t_i$ is a borrow, and so
%    $\mu_I$ is a borrow which results from the intersection of the sets of
%    leftvalues of all the $t_i$'s. Hence, $\mu_I$ is a lower bound of
%    $\{t_i\}_{i\in I}$.
%    Similarly if $t_k$ is a mutable borrow.
%
%    Now, suppose that $\mu'_I$ is also a lower bound of $\{t_i\}_{i\in I}$.
%    If $\mu'_I=\mathsf{int}$ then each $t_i$ is $\mathsf{int}$, so
%    $\mu_I=\mathsf{int}$ and we have $\mu'_I\sqsubseteq\mu_I$.
%    Similarly if $\mu'_I=\mathsf{dangling}$.
%    If $\mu'_I=\borrow b$, then for all $i\in I$ we have $t_i = \borrow b_i$
%    and $b \subseteq b_i$. Hence, $b \subseteq \cap_{i\in I}b_i$ and so
%    $\borrow b \sqsubseteq \borrow\cap_{i\in I}b_i$. Consequently, we have
%    $\mu'_I\sqsubseteq\mu_I$ because $\mu_I=\borrow\cap_{i\in I}b_i$ in this case.
%    Similarly if $\mu'_I$ is a mutable borrow.
%    %
%    \item (Induction step) Suppose that for all $i\in I$ we have
%    $t_i = \boxtype{t'_i}$. Since $\mu_I$ is defined, also
%    $\sqcap_{i\in I}t'_i$ is defined and, by inductive hypothesis, it must be the greatest
%    lower bound of $\{t'_i\}_{i\in I}$. Then,
%    $\mu_I = \boxtype{(\sqcap_{i\in I}t'_i)}$ is a lower bound
%    of $\{t_i\}_{i\in I}$. Suppose that $\mu'_I$ is also a lower bound
%    of $\{t_i\}_{i\in I}$. Then, $\mu'_I=\boxtype{t}$ with
%    $t\sqsubseteq t'_i$ for all $i\in I$, and so $t$ is a lower bound
%    of $\{t'_i\}_{i\in I}$; hence, we have $t\sqsubseteq \sqcap_{i\in I}t'_i$
%    because $\sqcap_{i\in I}t'_i$ is the greatest lower bound and,
%    consequently, $\mu'_I\sqsubseteq\mu_I$.
%  \end{itemize}
%  \qed
%\end{proof}

%\begin{lemma}\label{lemma:technical-type}
%  Let $t\in\mathsf{T}_\kappa$. For any $t_1,t_2\in\mathsf{T}_\kappa$,
%  if $t\sqsubseteq t_1$ and $t\sqsubseteq t_2$ then $t_1\sqcap t_2$ is defined.
%\end{lemma}
%\begin{proof}
%  We proceed by structural induction on $t$.
%  \begin{itemize}
%    \item (Base: $t$ is not a box)
%    Let $t_1,t_2\in\mathsf{T}_\kappa$ with $t\sqsubseteq t_1$ and $t\sqsubseteq t_2$.
%    If $t$ is $\mathsf{int}$ (resp. a borrow, a mutable borrow or $\mathsf{dangling}$)
%    then, necessarily, $t_1$ and $t_2$ are $\mathsf{int}$ (resp. a borrow,
%    a mutable borrow or $\mathsf{dangling}$), hence $t_1\sqcap t_2$ is defined.
%    %
%    \item (Induction step) Suppose that $t = \boxtype{t'}$.
%    Let $t_1,t_2\in\mathsf{T}_\kappa$ with $t\sqsubseteq t_1$ and $t\sqsubseteq t_2$.
%    Then, necessarily, $t_1 = \boxtype{t'_1}$ and $t_2 = \boxtype{t'_2}$
%    with $t'\sqsubseteq t'_1$ and $t'\sqsubseteq t'_2$. By induction
%    hypothesis, $t'_1\sqcap t'_2$ is defined, so
%    $(\boxtype{t'_1}) \sqcap (\boxtype{t'_2}) = t_1 \sqcap t_2$ is defined.
%    \qed
%  \end{itemize}
%\end{proof}

\begin{definition}\label{def:lub}
  The $\sqcup$ operator over $\mathsf{T}_\kappa$ is defined as
  \begin{align*}
    \mathsf{int}\sqcup\mathsf{int} &= \mathsf{int}\\
    \borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} \sqcup \borrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\} &= \borrow(\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}\cup\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\})\\
    \mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} \sqcup \mutborrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\} &= \mutborrow(\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}\cup\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\})\\
    (\boxtype{t_1}) \sqcup (\boxtype{t_2}) &=\boxtype{(t_1\sqcup t_2)}\quad\text{if $t_1\sqcup t_2$ is defined}\\
    \mathsf{dangling}\sqcup\mathsf{dangling} &= \mathsf{dangling}.
  \end{align*}
  In all other cases, $t_1\sqcup t_2$ is undefined.
\end{definition}

\begin{lemma}\label{lemma:lub-type}
  Let $I\subseteq\mathbb{N}$ and $\{t_i\}_{i\in I}\subseteq\mathsf{T}_\kappa$.
  Then, if $\sqcup_{i\in I}t_i$ is defined, it is the least upper bound of
  $\{t_i\}_{i\in I}$.
\end{lemma}
\begin{proof}
  Assume that $\nu_I = \sqcup_{i\in I}t_i$ is defined.
  We proceed by structural induction.
  \begin{itemize}
    \item (Base: there is a $t_k$ which is not a box)
    If $t_k=\mathsf{int}$ then, as $\nu_I$ is defined, for all $i\in I$
    we have $t_i=\mathsf{int}$. Therefore, $\nu_I=\mathsf{int}$
    and so $\nu_I$ is an upper bound of $\{t_i\}_{i\in I}$.
    Similarly if $t_k=\mathsf{dangling}$.
    If $t_k$ is a borrow then, for all $i\in I$, $t_i$ is a borrow, and so
    $\nu_I$ is a borrow which results from the union of the sets of
    leftvalues of all the $t_i$'s. Hence, $\nu_I$ is an upper bound of
    $\{t_i\}_{i\in I}$.
    Similarly if $t_k$ is a mutable borrow.

    Now, suppose that $\nu'_I$ is also an upper bound of $\{t_i\}_{i\in I}$.
    If $\nu'_I=\mathsf{int}$ then each $t_i$ is $\mathsf{int}$, so
    $\nu_I=\mathsf{int}$ and we have $\nu_I\sqsubseteq\nu'_I$.
    Similarly if $\nu'_I=\mathsf{dangling}$.
    If $\nu'_I=\borrow b$, then for all $i\in I$ we have $t_i = \borrow b_i$
    and $b_i\subseteq b$. Hence, $\cup_{i\in I}b_i\subseteq b$ and so
    $\borrow\cup_{i\in I}b_i\sqsubseteq\borrow b$. Consequently, we have
    $\nu_I\sqsubseteq\nu'_I$ because $\nu_I=\borrow\cup_{i\in I}b_i$ in this case.
    Similarly if $\nu'_I$ is a mutable borrow.
    %
    \item (Induction step) Suppose that for all $i\in I$ we have
    $t_i = \boxtype{t'_i}$. Since $\nu_I$ is defined, also
    $\sqcup_{i\in I}t'_i$ is defined and, by inductive hypothesis, it must be
    the least upper bound of $\{t'_i\}_{i\in I}$. Then,
    $\nu_I = \boxtype{(\sqcup_{i\in I}t'_i)}$ is an upper bound
    of $\{t_i\}_{i\in I}$. Suppose that $\nu'_I$ is also an upper bound
    of $\{t_i\}_{i\in I}$. Then, $\nu'_I=\boxtype{t}$ with
    $t'_i\sqsubseteq t$ for all $i\in I$, and so $t$ is an upper bound
    of $\{t'_i\}_{i\in I}$; hence, we have $\sqcup_{i\in I}t'_i\sqsubseteq t$
    because $\sqcup_{i\in I}t'_i$ is the least upper bound and,
    consequently, $\nu_I\sqsubseteq\nu'_I$.
  \end{itemize}
  \qed
\end{proof}

We can now define the typings. They are a type environment, that is,
type information about the variables in scope at a given program point.

\begin{definition}[Typing]\label{def:typing}
  Given a context $\kappa$, a \emph{typing} $\tau$ over $\kappa$ is
  a map from the variables in $\kappa$ to types.
\end{definition}

A typing provides types to variables but can be used to type
leftvalues as well, as shown below. Def.~\ref{def:type} is a translation of
Def.~3.11 from~\cite{Pearce21}. It can be seen as an algorithm for typing leftvalues
and, as such, it is heavily used in the borrow checker formalized in~\cite{Pearce21}.
The algorithm queries the typing when the leftvalue is actually a variable,
and dereferences borrows or boxes when the leftvalue contains one or more
\<*> operations, recurring in the case of borrows.
Types \<int> and \<dangling> cannot be dereferenced, hence the
algorithm fails in that case for them.

\begin{definition}[Type of leftvalues]\label{def:type}
  Given a context $\kappa$, a typing $\tau$ over $\kappa$
  and $\mathsf{w}\in\Leftvalues_\kappa$, the partial function
  $\type(\mathsf{w},\tau)$ yields the type of $\mathsf{w}$ in $\tau$:
  \begin{align*}
    \type(x,\tau)&=\tau(x)\\
    \type(*\mathsf{w},\tau)&=\begin{cases}
    \text{undefined} & \text{if $\type(\mathsf{w},\tau)$ is undefined}\\
    \text{undefined} & \text{if $\type(\mathsf{w},\tau)=\mathsf{dangling}$}\\
    \text{undefined} & \text{if $\type(\mathsf{w},\tau)=\mathsf{int}$}\\
    \sqcup_{1\le i\le n}\type(\mathsf{w}_i,\tau) & \text{if $\type(\mathsf{w},\tau)=\borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}$}\\
    \sqcup_{1\le i\le n}\type(\mathsf{w}_i,\tau) & \text{if $\type(\mathsf{w},\tau)=\mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}$}\\
    t & \text{if $\type(\mathsf{w},\tau)=\boxtype{t}$.}
    \end{cases}
  \end{align*}
\end{definition}

\noindent
Note that $\sqcup$ might be undefined for the cases of $\borrow$
and $\borrow\mathtt{mut}$.
As hinted in~\cite{Pearce21}, this corresponds to a situation when the program
is not well typed, in the traditional sense of type checking.

Def.~\ref{def:type} is clearly recursive, both on the structure of $\mathsf{w}$ and
on the leftvalues contained in the borrows or mutable borrows that occur in the typing.
In general, that recursion is not well-founded. In algorithmic terms, this means
that the algorithm for computing the type of leftvalues might not terminate.
Consider for instance the typing $\{x\to\borrow\{\mathtt{*}x\}\}$:
the definition of $\type(\mathtt{*}x,\tau)$ ends in an infinite loop.
This example can be arbitrarily complicated, through the
use of more involved cycles that pass through more variables. As a consequence,
the natural question is to understand when the recursion in
Def.~\ref{def:type} is well-founded and if that is always the case when it is
used by the borrow checker of Rust.
