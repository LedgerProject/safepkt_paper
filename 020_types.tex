\section{Semantics}\label{sec:semantics}

\begin{definition}
  We assume there is a set of variables $\Vars$.
  A context $\kappa\subseteq\Vars$ is a finite set of variables in scope.
  The set $\Leftvalues_\kappa$ of \emph{leftvalues} over $\kappa$ is defined as:
  \begin{align*}
    \mathsf{w} ::= &\ x & \text{variable, with $x\in\kappa$}\\
    | &\ \mathtt{*}\mathsf{w} & \text{dereference.}
  \end{align*}
  The \emph{root} of a leftvalue is the starting variable to which the dereferences of the
  leftvalue are applied. Namely, we define
  \begin{align*}
    \mathsf{root}(x) &= x\qquad\text{if $x\in\Vars$}\\
    \mathsf{root}(\mathtt{*}\mathsf{w}) &= \mathsf{root}(\mathsf{w}).
  \end{align*}
\end{definition}

The types used by the borrow checker are somehow non-standard, in the sense
that they can describe primitive types (such as \<int>) or structures
dynamically allocated in memory (collectively represented by a box), but can also refer to
a borrow or mutable borrow of one or more leftvalues.
Moreover, a type can state that a value has been \emph{moved}, that is, assigned
to another owner. Consequently, it exists but cannot be dereferenced.
We write this as \<dangling>. In comparison to~\cite{Pearce21}, we are using
a slight simplified set of types here, since~\cite{Pearce21} provides
the \emph{ghost} type $t$ of a value that has been moved, as $\<dangling>(t)$.
This information is important to ensure that a variable is subsequently
reassigned a value compatible
with its type $t$. However, we abstract this detail here, since it does not contribute to
the termination of the algorithm for typing leftvalues.

\begin{definition}[Types]
  The set of \emph{types} over a context $\kappa$ is
  \begin{align*}
    \mathsf{T}_\kappa ::=&\ \mathsf{int} & \text{integer}\\
    | &\ \borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} & \text{borrow}\\
    | &\ \mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} & \text{mutable borrow}\\
    | &\ \boxtype{\mathsf{T}_\kappa} & \text{box}\\
    | &\ \mathsf{dangling} & \text{dangling}
  \end{align*}
  where $n\ge 1$ and $\mathsf{w}_i\in\Leftvalues_\kappa$ for $1\le i\le n$.
  This set is ordered by $\sqsubseteq$, defined as
  \begin{align*}
    \mathsf{int}&\sqsubseteq\mathsf{int}\\
    \borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} & \sqsubseteq
    \borrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\} \quad\text{iff $\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}\subseteq\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\}$}\\
    \mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} & \sqsubseteq
    \mutborrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\} \quad\text{iff $\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}\subseteq\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\}$}\\
    \boxtype{t_1}&\sqsubseteq\boxtype{t_2} \quad\text{iff $t_1\sqsubseteq t_2$}\\
    \mathsf{dangling}&\sqsubseteq\mathsf{dangling.}
  \end{align*}
\end{definition}

We state now some results about the set of types and report
the greatest lower bound and least upper bound operators on types.

\begin{lemma}
  \label{lemma:partial-order-types}
  $(\mathsf{T}_\kappa,\sqsubseteq)$ is a partially ordered set.
\end{lemma}
\begin{proof}
  We proceed by structural induction.
  \begin{itemize}
    \item (Reflexivity)
    \begin{itemize}
      \item (Base) For any type $t$ that is not a box we have
      $t\sqsubseteq t$.
      \item (Induction step) If $t\sqsubseteq t$ for a type $t$ then
      $\boxtype{t}\sqsubseteq \boxtype{t}$.
    \end{itemize}
    %
    \item (Antisymmetry) Suppose that $t_1 \sqsubseteq t_2$ and
    $t_2 \sqsubseteq t_1$.
    \begin{itemize}
      \item (Base: $t_1$ or $t_2$ is not a box)
      If $t_1$ or $t_2$ is $\mathsf{int}$, then so is the other
      because $\mathsf{int}$ can only be greater than itself, and so $t_1 = t_2$.
      Similarly if $t_1$ or $t_2$ is $\mathsf{dangling}$.
      If $t_1$ or $t_2$ is a borrow, then so is the other because
      a borrow can only precede a borrow, and so we have $t_1 = t_2$
      by antisymmetry of $\subseteq$.
      Similarly if $t_1$ or $t_2$ is a mutable borrow.
      \item (Induction step) Suppose that $t_1=\boxtype{t'_1}$ and
      $t_2=\boxtype{t'_2}$ for types $t'_1,t'_2$ such that
      $(t'_1 \sqsubseteq t'_2 \land t'_2 \sqsubseteq t'_1) \Rightarrow t'_1 = t'_2$.
      As $t_1 \sqsubseteq t_2$ and $t_2 \sqsubseteq t_1$, we have
      $t'_1 \sqsubseteq t'_2$ and $t'_2 \sqsubseteq t'_1$, so
      $t'_1 = t'_2$, hence $t_1 = t_2$.
    \end{itemize}
    %
    \item (Transitivity) Suppose that $t_1 \sqsubseteq t_2$ and $t_2 \sqsubseteq t_3$.
    \begin{itemize}
      \item (Base: $t_1$, $t_2$ or $t_3$ is not a box)
      If $t_1$, $t_2$ or $t_3$ is $\mathsf{int}$, we necessarily have
      $t_1=t_2=t_3=\mathsf{int}$ because $\mathsf{int}$ is only related to
      itself, and so $t_1\sqsubseteq t_3$. Similarly if
      $t_1$, $t_2$ or $t_3$ is $\mathsf{dangling}$.
      If $t_1$, $t_2$ or $t_3$ is a borrow, then so are the others because
      a borrow is only related to a borrow, and so we have
      $t_1\sqsubseteq t_3$ by transitivity of $\subseteq$.
      Similarly if $t_1$, $t_2$ or $t_3$ is a mutable borrow.
      \item (Induction step) Suppose that $t_1=\boxtype{t'_1}$,
      $t_2=\boxtype{t'_2}$ and $t_3=\boxtype{t'_3}$ for types
      $t'_1,t'_2,t'_3$ such that
      $(t'_1 \sqsubseteq t'_2 \land t'_2 \sqsubseteq t'_3) \Rightarrow
      t'_1 \sqsubseteq t'_3$.
      As $t_1 \sqsubseteq t_2$ and $t_2 \sqsubseteq t_3$, we have
      $t'_1 \sqsubseteq t'_2$ and $t'_2 \sqsubseteq t'_3$, so
      $t'_1 \sqsubseteq t'_3$, hence $t_1 \sqsubseteq t_3$.
    \end{itemize}
  \end{itemize}
  \qed
\end{proof}

\begin{definition}
  The $\sqcap$ operator over $\mathsf{T}_\kappa$ is defined as
  \begin{align*}
    \mathsf{int}\sqcap\mathsf{int} &= \mathsf{int}\\
    \borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} \sqcap \borrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\} &= \borrow(\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}\cap\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\})\\
    \mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} \sqcap \mutborrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\} &= \mutborrow(\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}\cap\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\})\\
    (\boxtype{t_1}) \sqcap (\boxtype{t_2}) &=\boxtype{(t_1\sqcap t_2)}\quad\text{if $t_1\sqcap t_2$ is defined}\\
    \mathsf{dangling}\sqcap\mathsf{dangling} &= \mathsf{dangling}.
  \end{align*}
  In all other cases, $t_1\sqcap t_2$ is undefined.
\end{definition}

\begin{lemma}\label{lemma:glb-type}
  Let $I\subseteq\mathbb{N}$ and $\{t_i\}_{i\in I}\subseteq\mathsf{T}_\kappa$.
  Then, if $\sqcap_{i\in I}t_i$ is defined, it is the greatest lower bound of $\{t_i\}_{i\in I}$.
\end{lemma}
\begin{proof}
  Assume that $\mu_I = \sqcap_{i\in I}t_i$ is defined.
  We proceed by structural induction.
  \begin{itemize}
    \item (Base: there is a $t_k$ which is not a box)
    If $t_k=\mathsf{int}$ then, as $\mu_I$ is defined, for all $i\in I$
    we have $t_i=\mathsf{int}$. Therefore, $\mu_I=\mathsf{int}$
    and so $\mu_I$ is a lower bound of $\{t_i\}_{i\in I}$.
    Similarly if $t_k=\mathsf{dangling}$.
    If $t_k$ is a borrow then, for all $i\in I$, $t_i$ is a borrow, and so
    $\mu_I$ is a borrow which results from the intersection of the sets of
    leftvalues of all the $t_i$'s. Hence, $\mu_I$ is a lower bound of
    $\{t_i\}_{i\in I}$.
    Similarly if $t_k$ is a mutable borrow.

    Now, suppose that $\mu'_I$ is also a lower bound of $\{t_i\}_{i\in I}$.
    If $\mu'_I=\mathsf{int}$ then each $t_i$ is $\mathsf{int}$, so
    $\mu_I=\mathsf{int}$ and we have $\mu'_I\sqsubseteq\mu_I$.
    Similarly if $\mu'_I=\mathsf{dangling}$.
    If $\mu'_I=\borrow b$, then for all $i\in I$ we have $t_i = \borrow b_i$
    and $b \subseteq b_i$. Hence, $b \subseteq \cap_{i\in I}b_i$ and so
    $\borrow b \sqsubseteq \borrow\cap_{i\in I}b_i$. Consequently, we have
    $\mu'_I\sqsubseteq\mu_I$ because $\mu_I=\borrow\cap_{i\in I}b_i$ in this case.
    Similarly if $\mu'_I$ is a mutable borrow.
    %
    \item (Induction step) Suppose that for all $i\in I$ we have
    $t_i = \boxtype{t'_i}$. Since $\mu_I$ is defined, also
    $\sqcap_{i\in I}t'_i$ is defined and, by inductive hypothesis, it must be the greatest
    lower bound of $\{t'_i\}_{i\in I}$. Then,
    $\mu_I = \boxtype{(\sqcap_{i\in I}t'_i)}$ is a lower bound
    of $\{t_i\}_{i\in I}$. Suppose that $\mu'_I$ is also a lower bound
    of $\{t_i\}_{i\in I}$. Then, $\mu'_I=\boxtype{t}$ with
    $t\sqsubseteq t'_i$ for all $i\in I$, and so $t$ is a lower bound
    of $\{t'_i\}_{i\in I}$; hence, we have $t\sqsubseteq \sqcap_{i\in I}t'_i$
    because $\sqcap_{i\in I}t'_i$ is the greatest lower bound and,
    consequently, $\mu'_I\sqsubseteq\mu_I$.
  \end{itemize}
  \qed
\end{proof}

\begin{lemma}\label{lemma:technical-type}
  Let $t\in\mathsf{T}_\kappa$. For any $t_1,t_2\in\mathsf{T}_\kappa$,
  if $t\sqsubseteq t_1$ and $t\sqsubseteq t_2$ then $t_1\sqcap t_2$ is defined.
\end{lemma}
\begin{proof}
  We proceed by structural induction on $t$.
  \begin{itemize}
    \item (Base: $t$ is not a box)
    Let $t_1,t_2\in\mathsf{T}_\kappa$ with $t\sqsubseteq t_1$ and $t\sqsubseteq t_2$.
    If $t$ is $\mathsf{int}$ (resp. a borrow, a mutable borrow or $\mathsf{dangling}$)
    then, necessarily, $t_1$ and $t_2$ are $\mathsf{int}$ (resp. a borrow,
    a mutable borrow or $\mathsf{dangling}$), hence $t_1\sqcap t_2$ is defined.
    %
    \item (Induction step) Suppose that $t = \boxtype{t'}$.
    Let $t_1,t_2\in\mathsf{T}_\kappa$ with $t\sqsubseteq t_1$ and $t\sqsubseteq t_2$.
    Then, necessarily, $t_1 = \boxtype{t'_1}$ and $t_2 = \boxtype{t'_2}$
    with $t'\sqsubseteq t'_1$ and $t'\sqsubseteq t'_2$. By induction
    hypothesis, $t'_1\sqcap t'_2$ is defined, so
    $(\boxtype{t'_1}) \sqcap (\boxtype{t'_2}) = t_1 \sqcap t_2$ is defined.
    \qed
  \end{itemize}
\end{proof}

\begin{definition}
  The $\sqcup$ operator over $\mathsf{T}_\kappa$ is defined as
  \begin{align*}
    \mathsf{int}\sqcup\mathsf{int} &= \mathsf{int}\\
    \borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} \sqcup \borrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\} &= \borrow(\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}\cup\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\})\\
    \mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} \sqcup \mutborrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\} &= \mutborrow(\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}\cup\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\})\\
    (\boxtype{t_1}) \sqcup (\boxtype{t_2}) &=\boxtype{(t_1\sqcup t_2)}\quad\text{if $t_1\sqcup t_2$ is defined}\\
    \mathsf{dangling}\sqcup\mathsf{dangling} &= \mathsf{dangling}.
  \end{align*}
  In all other cases, $t_1\sqcup t_2$ is undefined.
\end{definition}

\begin{lemma}\label{lemma:lub-type}
  Let $I\subseteq\mathbb{N}$ and $\{t_i\}_{i\in I}\subseteq\mathsf{T}_\kappa$.
  Then, if $\sqcup_{i\in I}t_i$ is defined, it is the least upper bound of
  $\{t_i\}_{i\in I}$.
\end{lemma}
\begin{proof}
  Assume that $\nu_I = \sqcup_{i\in I}t_i$ is defined.
  We proceed by structural induction.
  \begin{itemize}
    \item (Base: there is a $t_k$ which is not a box)
    If $t_k=\mathsf{int}$ then, as $\nu_I$ is defined, for all $i\in I$
    we have $t_i=\mathsf{int}$. Therefore, $\nu_I=\mathsf{int}$
    and so $\nu_I$ is an upper bound of $\{t_i\}_{i\in I}$.
    Similarly if $t_k=\mathsf{dangling}$.
    If $t_k$ is a borrow then, for all $i\in I$, $t_i$ is a borrow, and so
    $\nu_I$ is a borrow which results from the union of the sets of
    leftvalues of all the $t_i$'s. Hence, $\nu_I$ is an upper bound of
    $\{t_i\}_{i\in I}$.
    Similarly if $t_k$ is a mutable borrow.

    Now, suppose that $\nu'_I$ is also an upper bound of $\{t_i\}_{i\in I}$.
    If $\nu'_I=\mathsf{int}$ then each $t_i$ is $\mathsf{int}$, so
    $\nu_I=\mathsf{int}$ and we have $\nu_I\sqsubseteq\nu'_I$.
    Similarly if $\nu'_I=\mathsf{dangling}$.
    If $\nu'_I=\borrow b$, then for all $i\in I$ we have $t_i = \borrow b_i$
    and $b_i\subseteq b$. Hence, $\cup_{i\in I}b_i\subseteq b$ and so
    $\borrow\cup_{i\in I}b_i\sqsubseteq\borrow b$. Consequently, we have
    $\nu_I\sqsubseteq\nu'_I$ because $\nu_I=\borrow\cup_{i\in I}b_i$ in this case.
    Similarly if $\nu'_I$ is a mutable borrow.
    %
    \item (Induction step) Suppose that for all $i\in I$ we have
    $t_i = \boxtype{t'_i}$. Since $\nu_I$ is defined, also
    $\sqcup_{i\in I}t'_i$ is defined and, by inductive hypothesis, it must be
    the least upper bound of $\{t'_i\}_{i\in I}$. Then,
    $\nu_I = \boxtype{(\sqcup_{i\in I}t'_i)}$ is an upper bound
    of $\{t_i\}_{i\in I}$. Suppose that $\nu'_I$ is also an upper bound
    of $\{t_i\}_{i\in I}$. Then, $\nu'_I=\boxtype{t}$ with
    $t'_i\sqsubseteq t$ for all $i\in I$, and so $t$ is an upper bound
    of $\{t'_i\}_{i\in I}$; hence, we have $\sqcup_{i\in I}t'_i\sqsubseteq t$
    because $\sqcup_{i\in I}t'_i$ is the least upper bound and,
    consequently, $\nu_I\sqsubseteq\nu'_I$.
  \end{itemize}
  \qed
\end{proof}

We can now define the typings. They are a type environment, that is,
type information about the variables in scope at a given program point.

\begin{definition}[Typing]\label{def:typing}
  Given a context $\kappa$, a \emph{typing} $\tau$ over $\kappa$ is
  a map from the variables in $\kappa$ to types.
\end{definition}

A typing provides types to variables but can be used to type
leftvalues as well, as shown below. Def.~\ref{def:type} is a translation of
Def.~3.11 from~\cite{Pearce21}. It can be seen as an algorithm for typing leftvalues
and, as such, it is heavily used in the borrow checker formalized in~\cite{Pearce21}.
The algorithm queries the typing when the leftvalue is actually a variable,
and dereferences borrows or boxes when the leftvalue contains one or more
\<*> operations. Types \<int> and \<dangling> cannot be dereferenced, hence the
algorithm fails in that case for them.

\begin{definition}[Type of leftvalues]\label{def:type}
  Given a context $\kappa$, a typing $\tau$ over $\kappa$
  and $\mathsf{w}\in\Leftvalues_\kappa$, the partial function
  $\type(\mathsf{w},\tau)$ yields the type of $\mathsf{w}$ in $\tau$:
  \begin{align*}
    \type(x,\tau)&=\tau(x)\\
    \type(*\mathsf{w},\tau)&=\begin{cases}
    \text{undefined} & \text{if $\type(\mathsf{w},\tau)$ is undefined}\\
    \text{undefined} & \text{if $\type(\mathsf{w},\tau)=\mathsf{dangling}$}\\
    \text{undefined} & \text{if $\type(\mathsf{w},\tau)=\mathsf{int}$}\\
    \sqcup_{1\le i\le n}\type(\mathsf{w}_i,\tau) & \text{if $\type(\mathsf{w},\tau)=\borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}$}\\
    \sqcup_{1\le i\le n}\type(\mathsf{w}_i,\tau) & \text{if $\type(\mathsf{w},\tau)=\mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}$}\\
    t & \text{if $\type(\mathsf{w},\tau)=\boxtype{t}$}\\
    \text{undefined} & \text{otherwise.}
    \end{cases}
  \end{align*}
\end{definition}

\noindent
Note that $\sqcup$ might be undefined for the cases of $\borrow$
and $\borrow\mathtt{mut}$.
As hinted in~\cite{Pearce21}, that corresponds to a situation when the program
is not well typed, in the traditional sense of type checking.

Def.~\ref{def:typing} is clearly recursive, both on the structure of \<w> and
on the leftvalues contained in the borrows or mutable borrows that occur in the typing.
In general, that recursion is not well-founded. In algorithmic terms, this means
that the algorithm for computing the type of leftvalues might not terminate.

\begin{example}\label{ex:type_divergence}
  Consider the following typing:
  \[
  \{x\to\borrow\{\mathtt{*}x\}\}.
  \]
  Then the definition of $\type(\mathtt{*}x,\tau)$ ends in an infinite loop.
\end{example}

\noindent
Ex.~\ref{ex:type_divergence} can be arbitrarily complicated, through the
use of more involved cycles that pass through more variables. As a consequence,
the natural question is to understand when Def.~\ref{def:type} is well-founded.
For that, we start by defining a concept of dependencies between leftvalues.

\begin{definition}[Dependencies between leftvalues]\label{def:dependencies}
  Given a context $\kappa$ and a typing $\tau$ over $\kappa$, the \emph{dependencies between leftvalues}
  induced by $\tau$ are the relation $\gg$ defined as
  \[
  \mathsf{closure}\left(\{\mathtt{*}\mathsf{w}\gg\mathsf{w}\mid\mathsf{w}\in\Leftvalues_\kappa\}
  \cup\bigcup\limits_{x\in\kappa}\mathsf{dependencies}(x,\tau(x))\right)
  \]
  where
  \begin{align*}
    \mathsf{dependencies}(\mathsf{w},\mathsf{int})&=\varnothing\\
    \mathsf{dependencies}(\mathsf{w},\mathsf{dangling})&=\varnothing\\
    \mathsf{dependencies}(\mathsf{w},\boxtype{t})&=\mathsf{dependencies}(\mathtt{*}\mathsf{w},t)\\
    \mathsf{dependencies}(\mathsf{w},\borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\})&=\{\mathtt{*}\mathsf{w}\gg\mathsf{w}_i\mid 1\le i\le n\}\\
    \mathsf{dependencies}(\mathsf{w},\mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\})&=\{\mathtt{*}\mathsf{w}\gg\mathsf{w}_i\mid 1\le i\le n\}
  \end{align*}
  and
  \[
  \mathsf{closure}(R)=R\cup\left\{\underbrace{\mathtt{*}\cdots\mathtt{*}}_{n}\mathsf{w}_1\gg\mathsf{w}_3\left|
  \begin{array}{l}
    \mathsf{w}_1\gg\mathsf{w}_2\in R,\ \underbrace{\mathtt{*}\cdots\mathtt{*}}_{n\ge 0}\mathsf{w}_2\gg\mathsf{w}_3\in R\\
    \text{and $\mathsf{w_3}$ is a borrow that occurs in $\tau$}
  \end{array}\right.\right\}.
  \]
\end{definition}

\noindent
Note that the closure in Def.~\ref{def:dependencies} makes $\gg$ transitive.

Prop.~\ref{prop:acyclicity} proves that the dependencies between leftvalues
model the pattern of the recursion in Def.~\ref{def:type}. Moreover,
if the $\gg$ relation is acyclical, then $\gg$ (and consequently the recusion
in Def.~\ref{def:type}) are well-founded.

\begin{proposition}\label{prop:acyclicity}
  Given a context $\kappa$ and a typing $\tau$ over $\kappa$
  such that the dependencies between leftvalues induced by $\tau$ are acyclical,
  the recursion used in the definition of function $\type$ is well-founded and consistent with $\gg$.
\end{proposition}
\begin{proof}
  First we prove that $\gg$ is a well-founded relation. Assume the contrary. Then
  there is an infinite sequence of leftvalues
  $\mathsf{w}_1\gg\mathsf{w}_2\gg\cdots\gg\mathsf{w}_n\gg\cdots$.
  Since $\mathsf{w}\gg\mathsf{w}'\in\mathsf{dependencies}(x,t)$ entails that
  $\mathsf{w}'$ is one of the leftvalues that occur in the borrows of $\tau$ and
  since there is only a finite number of such $\mathsf{w}'$, the acyclicity of $\gg$ entails that
  there must be a $\mathsf{w}_k=\underbrace{\mathtt{*}\cdots\mathtt{*}}_{\text{$n$}}x$
  such that the subsequent $\mathsf{w}_i$, $i>k$,
  are not leftvalues that occur in the borrows in $\tau$. By Def.~\ref{def:dependencies},
  it can only be $\mathsf{w}_{k+i}=\underbrace{\mathtt{*}\cdots\mathtt{*}}_{\text{$\le n-i$}}x$
  and consequently the length of the sequence is $k+n$ at most, impossible since we assumed that
  it was infinite.

  We now prove that
  \begin{enumerate}
  \item for every $\mathsf{w}\in\Leftvalues_\kappa$, the
    recursive uses $\type(\mathsf{w}',\tau)$ that occur for the definition
    of $\type(\mathsf{w},\tau)$ are such that $\mathsf{w}\gg\mathsf{w}'$;
  \item when $\type(\mathsf{w},\tau)=\borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}$
    or $\type(\mathsf{w},\tau)=\mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}$
    then $\mathtt{*}\mathsf{w}\gg\mathsf{w}_i$ for every $1\le i\le n$.
  \end{enumerate}
  Note that (1) by itself means that
  the recursion used in the
  definition of function $\type$ is well-founded and consistent with $\gg$, but we will also
  need (2) in order to prove (1).
  We prove (1) and (2) by induction on $\mathsf{w}$ with respect to $\gg$.

  \begin{itemize}
  \item (Base case)
    If $\mathsf{w}$
    has no $\mathsf{w}'$ such that $\mathsf{w}\gg\mathsf{w}'$, then it must be $\mathsf{w}\in\Vars$.
    Hence there are no recursive uses of $\type$ in the definition of
    $\type(\mathsf{w},\tau)$ and (1) holds. Moreover, in this case
    $\type(\mathsf{w},\tau)=\tau(\mathsf{w})$ and if
    $\tau(\mathsf{w})=\borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}$ by Def.~\ref{def:dependencies}
    we conclude that $\mathtt{*}\mathsf{w}\gg\mathsf{w}_i$ for every $1\le i\le n$, hence (2) holds.
    Similarly when $\tau(\mathsf{w})=\mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}$.
  \item (Inductice case)
    Assume now that (1) and (2) hold for $\mathsf{w}$. Consider
    the recursive uses $\type(\mathsf{w}',\tau)$ in the definition of
    $\type(\mathtt{*}\mathsf{w},\tau)$. One such recursive use is
    $\type(\mathsf{w},\tau)$ and $\mathtt{*}\mathsf{w}\gg\mathsf{w}$.
    Others are inside the computation of $\type(\mathsf{w},\tau)$ and by inductive hypothesis
    (1) holds, that is, they occur on $\mathsf{w}'$ such that $\mathsf{w}\gg\mathsf{w}'$.
    Hence $\mathtt{*}\mathsf{w}\gg\mathsf{w}\gg\mathsf{w}'$ and by transitivity
    $\mathtt{*}\mathsf{w}\gg\mathsf{w}'$. Finally, there are recursive uses
    when $\type(\mathsf{w},\tau)=\borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}$
    or when $\type(\mathsf{w},\tau)=\mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}$
    namely, uses of
    $\type(\mathsf{w}_i,\tau)$ with $1\le i\le n$. By inductive hypothesis, we know that
    (2) holds for $\mathsf{w}$, that is, $\mathtt{*}\mathsf{w}\gg\mathsf{w}_i$ for every
    $1\le i\le n$. This concludes the inductive case for the proof of (1).
    Let us prove (2) for $\mathtt{*}\mathsf{w}$ now. Assume then that
    $\type(\mathtt{*}\mathsf{w},\tau)=\borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}$ (the case
    $\type(\mathtt{*}\mathsf{w},\tau)=\mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}$ is similar).
    By Def.~\ref{def:type}, there are two possibilities:
    \begin{itemize}
    \item $\mathtt{*}\mathsf{w}=\underbrace{\mathtt{*}\cdots\mathtt{*}}_{\text{$m+1$}}x$
      and $\tau(x)=\underbrace{\boxempty\cdots\boxempty}_{\text{$m+1$}}
      \borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}$
      for some $m\ge 0$, where $x=\mathsf{root}(\mathsf{w})$.
      By Def.~\ref{def:dependencies}, the relation $\gg$ includes
      \begin{align*}
        \mathsf{dependencies}(x,\tau(x))&=\mathsf{dependencies}(x,\underbrace{\boxempty\cdots\boxempty}_{\text{$m+1$}}\borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\})\\
        &=\mathsf{dependencies}(\underbrace{\mathtt{*}\cdots\mathtt{*}}_{\text{$m+1$}}x,
        \borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\})\\
        &=\mathsf{dependencies}(\mathtt{*}\mathsf{w},\borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\})\\
        &=\{\mathtt{**}\mathsf{w}\gg\mathsf{w}_i\mid 1\le i\le n\}
      \end{align*}
      and (2) holds for $\mathtt{*}\mathsf{w}$.
    \item $\borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}=\sqcup_{1\le i\le n'}\type(\mathsf{w}_i',\tau)$
      with $\type(\mathsf{w},\tau)=\borrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\}$.
      The only possibility is that $\type(\mathsf{w}_j',\tau)=\borrow W_j$ for every $1\le j\le n'$,
      with $\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}=\cup_{1\le j\le n'}W_i$.
      By inductive hypothesis of (2), we know that
      $\mathtt{*}\mathsf{w}\gg\mathsf{w}_j'$ for every $1\le j\le n'$ and that
      $\mathtt{*}\mathsf{w}_j'\gg\mathsf{w}''$ for every $\mathsf{w}''\in W_j$ and
      every $1\le j\le n'$. Note that $\mathsf{w}''$ is one of the leftvalues that occur
      in the borrows of $\tau$, by Def.~\ref{def:type}.
      By closure (Def.~\ref{def:dependencies}), we conclude that
      $\mathtt{**}\mathsf{w}\gg\mathsf{w}''$ for every $\mathsf{w}''\in W_j$ and
      every $1\le j\le n'$. Since each $\mathsf{w}_i$ belongs to some $W_j$, we conclude that
      $\mathtt{**}\mathsf{w}\gg\mathsf{w}_i$ for every $1\le i\le n$ and (2) holds for $\mathtt{*}\mathsf{w}$.
    \end{itemize}
  \end{itemize}
\end{proof}
