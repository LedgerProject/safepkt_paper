\section{Semantics}\label{sec:semantics}

\begin{definition}
  We assume there is a set of variables $\Vars$
  and a finite set $\Lifetimes$ of \emph{lifetimes}.
  The set of \emph{leftvalues} \textsf{w} is defined as:
  \begin{align*}
    \mathsf{w} ::= &\ x & \text{variable, with $x\in\Vars$}\\
    | &\ \mathtt{*}\mathsf{w} & \text{dereference}
  \end{align*}
  The set of \emph{expressions} \textsf{e} is defined as
  \begin{align*}
    \mathsf{e} ::= &\ i & \text{integer}\\
    | &\ \mathsf{w} & \text{leftvalue}\\
    | &\ \borrow\mathsf{w} & \text{borrow}\\
    | &\ \mathtt{mut}\borrow\mathsf{w} & \text{mutable borrow}\\
    | &\ \mathtt{box}\ \mathsf{e} & \text{heap allocation}
  \end{align*}
  The sets of \emph{terms} \textsf{t} and \emph{blocks} \textsf{b}
  is defined as:
  \begin{align*}
    \mathsf{t} ::= &\ \mathsf{w}=\mathsf{e} & \text{assignment}\\
    | &\ \mathtt{let\ mut}\ x=\mathsf{e} & \text{declaration, with $x\in\Vars$}\\
    | &\ \{\mathsf{t_1};\ldots;\mathsf{t_n}\}^l & \text{block, with $n\ge 0$ and $l\in\Lifetimes$}
  \end{align*}
\end{definition}

\begin{definition}[Static types]
  We assume that expressions in a program have a static type, written $\type(e)$, that allows one
  to identify expressions that contain a box or a mutable borrow. We will write that
  ``$\type(e)$ is a box'', and that ``$\type(e)$ is a $\texttt{mut}\borrow$'' for that, respectively.
  Expressions whose type is a box or a $\texttt{mut}\borrow$ are said to have move semantics.
  All other expressions have copy semantics.
\end{definition}

\begin{example}\label{ex:program}
  The following valid program $P_1$ consists of a block that contains
  an inner block.
  \[
    \{
      \mathtt{let\ mut}\ x = \mathtt{box}\ 0;\
      \{\mathtt{let\ mut}\ y = \mathtt{mut}\borrow x;\
      \mathtt{*}y = \mathtt{box}\ 1\}^l;\
      \mathtt{let\ mut}\ z = x
    \}^m
  \]
  \qed
\end{example}

\begin{definition}
  We assume that there is an infinite set $\Locs$ of \emph{locations}.
  The set of \emph{values} is defined as $\mathbb{V}=\mathbb{Z}\cup\Locs$,
  where $\mathbb{Z}$ is the set of integers.

  The set $\mathbb{E}$
  of \emph{environments} contains bindings from variables to locations,
  decorated with a \emph{lifetime}:
  % and existing in two versions, owned and not owned:
  \[
  \mathbb{E}=\{x\to^m\ell\mid x\in\Vars,\ m\in\Lifetimes\text{ and }\ \ell\in\Locs\}
  \]
  with the constraint that, for each $\rho\in\mathbb{E}$, there is at most a binding for each
  given variable $x$. Moreover, we write $\rho(x)=\ell$ when
  $x\rightarrow^m\ell\in\rho$, for some $m$.

  The set $\mathbb{H}$ of \emph{heaps} contains bindings from locations to values,
  existing in three versions: owned, not owned and mutable borrows:
  \[
  \mathbb{H}=
  \underbrace{\{\ell\Rightarrow\ell'\mid\ell,\ell'\in\Locs\}}_{\text{owned bindings}}
  \cup
  \underbrace{\{\ell\rightarrow v\mid\ell\in\Locs\text{ and }v\in\mathbb{V}\}}_{\text{not owned bindings}}
  \cup
  \underbrace{\{\ell\leadsto\ell'\mid\ell,\ell'\in\Locs\}}_{\text{mutable borrows}}
  \]
  with the constraint that, for each $h\in\mathbb{H}$, there is at most a binding for each
  location $\ell$ (owned, not owned or mutable borrow). We write $h(\ell)=v$ meaning that
  either $\ell\Rightarrow v\in h$ or $\ell\rightarrow v\in h$ or $\ell\leadsto v\in h$.
  Given $L\subseteq\Locs$,
  we write $h|_{-L}$ meaning $h$ where the bindings for the locations in $L$
  have been removed (if any).

  The set of \emph{stores} $\mathbb{S}$ is the set of pairs
  $\mathbb{E}\times\mathbb{H}$, whose elements are written as $\rho\star h$.
  Given $s=\rho\star h\in\mathbb{S}$, we define $s(x)=\rho(x)$ for all
  $x\in\Vars$, and $s(\ell)=h(\ell)$ for all $\ell\in\Locs$.
  Given $L\subseteq\Locs$, we define $(\rho\star h)|_{-L}=\rho\star(h|_{-L})$.
\end{definition}

\noindent
We observe that the above definition of $\mathbb{H}$ allows one to represent mutable borrows
through the $\leadsto$ bindings, but also normal (that is, non-mutable) borrows, that are
just a special case of not owned bindings, hence through the $\to$ bindings.

\begin{definition}[Borrowed locations]
  Let $h\in\mathbb{H}$. % and $l'\in\Locs$.
  A location $\ell$ is \emph{non-mutably borrowed} in $h$
  if there exists $\ell'\in\Locs$ such that $\ell'\to\ell$.
  A location $\ell$ is \emph{mutably borrowed} in $h$
  if there exists $\ell'\in\Locs$ such that $\ell'\leadsto\ell$.
  A location $\ell$ is \emph{borrowed} in $h$
  if it is mutably or non-mutably borrowed in $h$.
\end{definition}

\begin{definition}[Consistent heaps]
  Given $h\in\mathbb{H}$, it is \emph{consistent} when
  \begin{enumerate}
  \item no location is at the same time mutably and non-mutably borrowed in $h$
  \item no location is mutably borrowed more than once, that is, for every
    $\ell\in\Locs$ there are not $\ell'\in\Locs$ and $\ell''\in\Locs$ such that
    $\ell'\not=\ell''$, $\ell'\leadsto\ell\in h$ and $\ell''\leadsto\ell\in h$.
  \end{enumerate}
  We say that a store is consistent when its heap is consistent.
\end{definition}

\begin{definition}[Locate]\label{def:locate}
  The partial function $\loc(\mathsf{w},s)$ determines the location that holds
  the value of the leftvalue $\mathsf{w}$ in $s\in\mathbb{S}$, as follows:
  \begin{align*}
    \loc(x,s) &= s(x)\\
    \loc(*\mathsf{w},s) &= \left\{\begin{array}{ll}
      s(\loc(\mathsf{w},s)) & \text{if } s(\loc(\mathsf{w},s)) \in \Locs\\
      \text{undefined} & \text{otherwise}
    \end{array}\right.
  \end{align*}
\end{definition}

\noindent
Note that $\loc$ is a partial function since the second case of
Def.~\ref{def:locate} is undefined when
$s(\loc(\mathsf{w},s))\not\in\Locs$. In the following, when $\loc$ is undefined, the
semantics will be stuck.

\begin{example}
  Let $\rho = \left\{x\rightarrow^m\ell_x\right\}$.
  \begin{itemize}
    \item Let $s = \rho\star h$ with
    $h = \left\{\ell_x\rightarrow\ell,\ \ell\rightarrow 1\right\}$.
    Then, $s(\loc(x,s)) = s(s(x)) = s(\rho(x)) = s(\ell_x) =
    h(\ell_x) = \ell\in\Locs$, so
    $\loc(\mathtt{*}x,s)= s(\loc(x,s)) = \ell$.
    %
    \item Let $s' = \rho\star h'$ with
    $h' = \left\{\ell_x\rightarrow 1\right\}$. Then,
    $s'(\loc(x,s')) = s'(s'(x)) = s'(\rho(x)) = s'(\ell_x) =
    h'(\ell_x) = 1 \not\in\Locs$, so $\loc(\mathtt{*}x,s')$ is undefined.
    \qed
  \end{itemize}
\end{example}

The evaluation of a leftvalue yields the value of the leftvalue and a potentially updated heap:

\begin{definition}[Semantics of leftvalues]\label{def:semantics_leftvalues}
  Given $s=\rho\star h$, we define
  \[
  \den[\mathsf{w}]{s}=\begin{cases}
  \langle s(\loc(\mathsf{w},s)), h\rangle & \text{if $\type(\mathsf{w})$ has copy semantics}\\
  \langle s(\loc(\mathsf{w},s)), h|_{-\loc(\mathsf{w},s)}\rangle & \text{if $\type(\mathsf{w})$ has move semantics}
  \end{cases}
  \]
\end{definition}

\noindent
Note that the second case above makes $\mathsf{w}$ point to a dangling location, hence
$\mathsf{w}$ becomes unusable.

The evaluation of an expression yields the value of the expression and a potentially updated heap:

\begin{definition}[Semantics of expressions]\label{def:semantics_expressions}
  Given $s=\rho\star h$, we define
  \begin{align*}
    \den[i]{s}&=\langle i,h\rangle\\
    \den[\borrow\mathsf{w}]{s}&=\langle\loc(\mathsf{w},s),h\rangle\\
    \den[\mathtt{mut}\borrow\mathsf{w}]{s}&=\langle\loc(\mathsf{w},s),h\rangle\\
    \den[\mathtt{box}\ \mathsf{e}]{s}&=
    \begin{cases}
      \langle\ell,h'\cup\{\ell\Rightarrow v\}\rangle & \text{if $\type(e)$ is a box}\\
      \langle\ell,h'\cup\{\ell\leadsto v\}\rangle & \text{otherwise, if $\type(e)$ is $\mathtt{mut}\borrow$}\\
      \langle\ell,h'\cup\{\ell\to v\}\rangle & \text{otherwise}
    \end{cases}\\
    & \text{where $\den[\mathsf{e}]{s}=\langle v, h'\rangle$ and $\ell$ is fresh}
  \end{align*}
  For expressions that are leftvalues, see Def.~\ref{def:semantics_leftvalues}.
\end{definition}

The set of locations reachable by following owned bindings only, and starting from a set of locations $\psi$,
is defined as follows:
%
\begin{definition}[Owned reachable locations]
  Given $\psi\subseteq\Locs$ and $h\in\mathbb{H}$, we define
  \begin{align*}
  \omega^0(\psi,h)&=\psi\\ %\{\ell'\in\Locs\mid\ell\in\psi\text{ and }\ell\Rightarrow\ell'\in h\}\\
  \omega^{i+1}(\psi,h)&=\{\ell'\in\Locs\mid\ell\in\omega^i(\psi,h)\text{ and }\ell\Rightarrow\ell'\in h\}
  \end{align*}
  and
  \[
  \omega(\psi,h)=\bigcup\limits_{i\ge 0}\omega^i(\psi,h)~.
  \]
\end{definition}

The function $\drop$ removes the owned locations reachable from a set of locations.
%
\begin{definition}[Drop]\label{def:drop}
  The function $\drop:\wp(\Locs)\times\mathbb{H}\to\mathbb{H}$ is defined as
  \[
  \drop(\psi,h)=h|_{-{\omega(\psi,h)}}~.
  \]
\end{definition}

\begin{definition}[Semantics of terms]\label{def:semantics_terms}
  Given $s=\rho\star h$ and $m\in\Lifetimes$, we define
  \begin{align*}
    \denl[\mathsf{w}=\mathsf{e}]{m}{s}&=
    \begin{cases}
      \text{undefined} & \text{if $\ell$ is borrowed in $h'$}\\
      \langle\rho,h''[\ell\Rightarrow v]\rangle & \text{otherwise, if $\type(e)$ is a box}\\
      \langle\rho,h''[\ell\leadsto v]\rangle & \text{otherwise, if $\type(e)$ is a $\mathtt{mut}\borrow$ and $h''[\ell\leadsto v]$ is consistent}\\
      \langle\rho,h''[\ell\to v]\rangle & \text{otherwise, if $h''[\ell\to v]$ is consistent}\\
      \text{undefined} & \text{otherwise}
    \end{cases}\\
    &\text{where $\den[\mathsf{e}]{s}=\langle v,h'\rangle$, $\ell=\loc(\mathsf{w},\langle\rho,h'\rangle)$ and
      $h''=\drop(\{\ell\},h')$}\\
    \mbox{}\\
    \denl[\mathtt{let\ mut}\ x=\mathsf{e}]{m}{s}&=
    \begin{cases}
      \langle\rho[x\to^m\ell],h'[\ell\Rightarrow v]\rangle & \text{if $\type(e)$ is a box}\\
      \langle\rho[x\to^m\ell],h'[\ell\leadsto v]\rangle & \text{otherwise, if $\type(e)$ is a $\mathtt{mut}\borrow$ and $h'[\ell\leadsto v]$ is consistent}\\
      \langle\rho[x\to^m\ell],h'[\ell\to v]\rangle & \text{otherwise, if $h'[\ell\to v]$ is consistent}\\
      \text{undefined} & \text{otherwise}
    \end{cases}\\
    &\text{where $\den[\mathsf{e}]{s}=\langle v,h'\rangle$ and $\ell$ is fresh}\\
    \mbox{}\\
    \denl[\{\mathsf{t_1};\ldots;\mathsf{t_n}\}^l]{m}{s}&=\langle\rho,\drop(\{\ell\mid x\to^l\ell\in\rho'\},h')\rangle\\
    &\text{where $\langle\rho',h'\rangle=\denl[\mathsf{t_n}]{l}{\denl[\mathsf{t_{n-1}}]{l}{\cdots\denl[\mathsf{t_1}]{l}{s}}}$.}
  \end{align*}
\end{definition}

\begin{example}
  Consider again the program $P_1$ of Ex.~\ref{ex:program}:
  \[
    \{
      \mathtt{let\ mut}\ x = \mathtt{box}\ 0;\
      \{\mathtt{let\ mut}\ y = \mathtt{mut}\borrow x;\
      \mathtt{*}y = \mathtt{box}\ 1\}^l;\
      \mathtt{let\ mut}\ z = x
    \}^m
  \]
  \begin{itemize}
    \item Let $s_0=\emptyset \star \emptyset$.
    We have $\den[0]{s_0} = \langle 0,\emptyset\rangle$, hence
    $\den[\mathtt{box}\ 0]{s_0} =
    \langle\ell,\{\ell\to 0\}\rangle$ where $\ell$ is fresh.
    %
    Consequently, we have
    $\denl[\mathtt{let\ mut}\ x = \mathtt{box}\ 0]{m}{s_0} =
    \langle \rho_1,\ h_1\rangle$ where
    \[\rho_1=\{x\to^m\ell_x\} \qquad
    h_1 = \{\ell_x\Rightarrow \ell,\ \ell\to 0\}\]
    and $\ell_x$ is fresh.
    %
    \item Let $s_1 = \rho_1 \star h_1$.
    Then, we have $\loc(x,s_1) = \ell_x$, so
    $\den[\mathtt{mut}\borrow x]{s_1} = \langle\ell_x, h_1\rangle$.
    Therefore, we have
    $\denl[\mathtt{let\ mut}\ y = \mathtt{mut}\borrow x]{l}{s_1} =
    \langle \rho_2,\ h_2\rangle$
    where
    \begin{align*}
      \rho_2 & = \rho_1[y\to^l\ell_y] = \{y\to^l\ell_y,\ x\to^m\ell_x\}\\
      h_2 & = h_1[\ell_y\leadsto \ell_x] =
      \{\ell_y\leadsto \ell_x,\ \ell_x\Rightarrow \ell,\ \ell\to 0\}
    \end{align*}
    and $\ell_y$ is fresh.
    %
    \item Let $s_2 = \rho_2 \star h_2$.
    We have $\den[1]{s_2} = \langle 1,h_2\rangle$, hence
    $\den[\mathtt{box}\ 1]{s_2} =
    \langle\ell',h_2[\ell'\to 1]\rangle$ where $\ell'$ is fresh.
    %
    If we let $s'_2=\langle\rho_2,h_2[\ell'\to 1]\rangle$,
    we have $\loc(\mathtt{*}y,s'_2) = s'_2(\loc(y,s'_2)) =
    s'_2(s'_2(y)) = s'_2(\rho_2(y)) = s'_2(\ell_y) = h_2[\ell'\to 1](\ell_y)
    = \ell_x$. Moreover, $h^{''}_2=\drop(\{\ell_x\},h_2[\ell'\to 1]) =
    \{\ell_y\leadsto \ell_x,\ell'\to 1\}$. Consequently,
    $\denl[\mathtt{*}y = \mathtt{box}\ 1]{l}{s_2} =
    \langle\rho_3,h_3\rangle$ where
    \[\rho_3 = \rho_2
    \text{ and }
    h_3 = \{\ell_y\leadsto\ell_x,\ell_x\Rightarrow\ell',
    \ell'\to 1\}\]
    %
    \item Let us evaluate
    $\denl[\{\mathtt{let\ mut}\ y = \mathtt{mut}\borrow x;\
    \mathtt{*}y = \mathtt{box}\ 1\}^l]{m}{s_1}$. Above, we have
    computed $\denl[\mathtt{*}y = \mathtt{box}\ 1]{l}{
    \denl[\mathtt{let\ mut}\ y = \mathtt{mut}\borrow x]{l}{s_1}} =
    \langle\rho_3,h_3\rangle$. Moreover,
    $\drop(\{\ell\mid x\to^l\ell\in\rho_3\},h_3) = \drop(\{\ell_y\},h_3) =
    \{\ell_x\Rightarrow\ell',\ell'\to 1\}$. Consequently,
    $\denl[\{\mathtt{let\ mut}\ y = \mathtt{mut}\borrow x;\
    \mathtt{*}y = \mathtt{box}\ 1\}^l]{m}{s_1} =
    \langle \rho_4,h_4\rangle$ where
    \[\rho_4 = \rho_1 \text{ and } h_4 = \{\ell_x\Rightarrow\ell',\ell'\to 1\}\]
    %
    \item Let $s_4 = \rho_4 \star h_4$. As $\type(x)$ is a box,  $x$ has
    move semantics. Consequently, $\den[x]{s_4} =
    \langle s_4(\loc(x,s_4)), {h_4}|_{-\loc(x,s_4)}\rangle$
    with $\loc(x,s_4)=\ell_x$ and $s_4(\loc(x,s_4)) = s_4(\ell_x)
    = h_4(\ell_x)=\ell'$\ie
    $\den[x]{s_4} = \langle \ell', \{\ell'\to 1\} \rangle$.
    So, $\denl[\mathtt{let\ mut}\ z = x]{m}{s_4} = \langle \rho_5,h_5\rangle$
    where
    \begin{align*}
      \rho_5 & = \rho_4[z\to^m \ell_z] = \{z\to^m \ell_z,\ x\to^m\ell_x\}\\
      h_5 & = \{\ell_z\Rightarrow \ell',\ \ell'\to 1\}
    \end{align*}
    and $\ell_z$ is fresh.
  \end{itemize}
  \qed
\end{example}

\begin{example}
  Consider the following illegal program $P_2$
  that attempts to create two mutable references
  to the same piece of data in the same scope:
  \[
    \{
      \mathtt{let\ mut}\ x = 13;\
      \mathtt{let\ mut}\ y = \mathtt{mut}\borrow x;\
      \mathtt{let\ mut}\ z = \mathtt{mut}\borrow x
    \}^m
  \]
  \begin{itemize}
    \item Let $s_0=\emptyset \star \emptyset$.
    We have $\den[13]{s_0} = \langle 13,\emptyset\rangle$, hence
    $\denl[\mathtt{let\ mut}\ x = 13]{m}{s_0} =
    \langle \rho_1,\ h_1\rangle$ where
    \[\rho_1=\{x\to^m\ell_x\} \qquad
    h_1 = \{\ell_x\to 13\}\]
    and $\ell_x$ is fresh.
    %
    \item Let $s_1 = \rho_1 \star h_1$.
    Then, we have $\loc(x,s_1) = \ell_x$, so
    $\den[\mathtt{mut}\borrow x]{s_1} = \langle \ell_x,h_1\rangle$.
    Therefore, we have
    $\denl[\mathtt{let\ mut}\ y = \mathtt{mut}\borrow x]{m}{s_1} =
    \langle \rho_2,\ h_2\rangle$
    where
    \begin{align*}
      \rho_2 & = \rho_1[y\to^m\ell_y] = \{y\to^m\ell_y,\ x\to^m\ell_x\}\\
      h_2 & = h_1[\ell_y\leadsto \ell_x] =
      \{\ell_y\leadsto \ell_x,\ \ell_x\to 13\}
    \end{align*}
    and $\ell_y$ is fresh.
    %
    \item Let $s_2 = \rho_2 \star h_2$.
    Then, we have $\loc(x,s_2) = \ell_x$, so
    $\den[\mathtt{mut}\borrow x]{s_2} = \langle \ell_x,h_2\rangle$.
    As $h_2[\ell_z\leadsto \ell_x]$ is not consistent for any fresh location
    $\ell_z$, we have that
    $\denl[\mathtt{let\ mut}\ z = \mathtt{mut}\borrow x]{m}{s_2}$
    is undefined.
  \end{itemize}
  \qed
\end{example}

\begin{example}
  Consider the following valid program $P'_2$ which is a variant
  of $P_2$ with immutable references:
  \[
    \{
      \mathtt{let\ mut}\ x = 13;\
      \mathtt{let\ mut}\ y = \borrow x;\
      \mathtt{let\ mut}\ z = \borrow x
    \}^m
  \]
  \begin{itemize}
    \item Let $s_0=\emptyset \star \emptyset$.
    We have $\den[13]{s_0} = \langle 13,\emptyset\rangle$, hence
    $\denl[\mathtt{let\ mut}\ x = 13]{m}{s_0} =
    \langle \rho_1,\ h_1\rangle$ where
    \[\rho_1=\{x\to^m\ell_x\} \qquad
    h_1 = \{\ell_x\to 13\}\]
    and $\ell_x$ is fresh.
    %
    \item Let $s_1 = \rho_1 \star h_1$.
    Then, we have $\loc(x,s_1) = \ell_x$, so
    $\den[\borrow x]{s_1} = \langle \ell_x,h_1\rangle$.
    Therefore, we have
    $\denl[\mathtt{let\ mut}\ y = \borrow x]{m}{s_1} =
    \langle \rho_2,\ h_2\rangle$
    where
    \begin{align*}
      \rho_2 & = \rho_1[y\to^m\ell_y] = \{y\to^m\ell_y,\ x\to^m\ell_x\}\\
      h_2 & = h_1[\ell_y\to \ell_x] =
      \{\ell_y\to \ell_x,\ \ell_x\to 13\}
    \end{align*}
    and $\ell_y$ is fresh.
    %
    \item Let $s_2 = \rho_2 \star h_2$.
    Then, we have $\loc(x,s_2) = \ell_x$, so
    $\den[\borrow x]{s_2} = \langle \ell_x,h_2\rangle$.
    Therefore, we have
    $\denl[\mathtt{let\ mut}\ z = \borrow x]{m}{s_2} =
    \langle \rho_3,\ h_3\rangle$
    where
    \begin{align*}
      \rho_3 & = \rho_2[z\to^m\ell_z] = \{z\to^m\ell_z,\ y\to^m\ell_y,\ x\to^m\ell_x\}\\
      h_3 & = h_2[\ell_z\to \ell_x] =
      \{\ell_z\to \ell_x,\ \ell_y\to \ell_x,\ \ell_x\to 13\}
    \end{align*}
    and $\ell_y$ is fresh.
  \end{itemize}
  \qed
\end{example}

\begin{example}
  Consider the following illegal program $P_3$
  where variable $x$ is assigned to $1$ while
  borrowed to $y$:
  \[
    \{
      \mathtt{let\ mut}\ x = 0;\
      \mathtt{let\ mut}\ y = \mathtt{mut}\borrow x;\
      x = 1
    \}^m
  \]
  \begin{itemize}
    \item Let $s_0=\emptyset \star \emptyset$.
    We have $\den[0]{s_0} = \langle 0,\emptyset\rangle$, hence
    $\denl[\mathtt{let\ mut}\ x = 0]{m}{s_0} =
    \langle \rho_1,\ h_1\rangle$ where
    \[\rho_1=\{x\to^m\ell_x\} \qquad
    h_1 = \{\ell_x\to 0\}\]
    and $\ell_x$ is fresh.
    %
    \item Let $s_1 = \rho_1 \star h_1$.
    Then, we have $\loc(x,s_1) = \ell_x$, so
    $\den[\mathtt{mut}\borrow x]{s_1} = \langle \ell_x,h_1\rangle$.
    Therefore, we have
    $\denl[\mathtt{let\ mut}\ y = \mathtt{mut}\borrow x]{m}{s_1} =
    \langle \rho_2,\ h_2\rangle$
    where
    \begin{align*}
      \rho_2 & = \rho_1[y\to^m\ell_y] = \{y\to^m\ell_y,\ x\to^m\ell_x\}\\
      h_2 & = h_1[\ell_y\leadsto \ell_x] =
      \{\ell_y\leadsto \ell_x,\ \ell_x\to 0\}
    \end{align*}
    and $\ell_y$ is fresh.
    %
    \item Let $s_2 = \rho_2 \star h_2$.
    Then, we have $\den[1]{s_2} = \langle 1,h'_2\rangle$ with $h'_2=h_2$.
    Moreover, $\loc(x,\langle\rho_2,h'_2\rangle) = \ell_x$ is
    mutably borrowed in $h'_2$.
    Therefore, $\denl[x = 1]{m}{s_2}$ is undefined.
  \end{itemize}
  \qed
\end{example}
