\section{Semantics}\label{sec:semantics}

\begin{definition}
  We assume there is a set of variables $\Vars$
  and a finite set $\Lifetimes$ of \emph{lifetimes}.
  The set of \emph{leftvalues} \textsf{w} is defined as:
  \begin{align*}
    \mathsf{w} ::= &\ x & \text{variable, with $x\in\Vars$}\\
    | &\ \mathtt{*}\mathsf{w} & \text{dereference}
  \end{align*}
  The set of \emph{expressions} \textsf{e} is defined as
  \begin{align*}
    \mathsf{e} ::= &\ i & \text{integer}\\
    | &\ \mathsf{w} & \text{leftvalue}\\
    | &\ \borrow\mathsf{w} & \text{borrow}\\
    | &\ \mathtt{mut}\borrow\mathsf{w} & \text{mutable borrow}\\
    | &\ \mathtt{box}\ \mathsf{e} & \text{heap allocation}
  \end{align*}
  The sets of \emph{terms} \textsf{t} and \emph{blocks} \textsf{b}
  is defined as:
  \begin{align*}
    \mathsf{t} ::= &\ \mathsf{w}=\mathsf{e} & \text{assignment}\\
    | &\ \mathtt{let\ mut}\ x=\mathsf{e} & \text{declaration, with $x\in\Vars$}\\
    | &\ \{\mathsf{t_1};\ldots;\mathsf{t_n}\}^l & \text{block, with $n\ge 0$ and $l\in\Lifetimes$}
  \end{align*}
\end{definition}

\begin{example}\label{ex:program}
  The following valid program consists of a block that contains an inner block.
  \[
    \{
      \mathtt{let\ mut}\ x = \mathtt{box}\ 0;\
      \{\mathtt{let\ mut}\ y = \mathtt{mut}\borrow x;\
      \mathtt{*}y = \mathtt{box}\ 1\}^l;\
      \mathtt{let\ mut}\ z = x
    \}^m
  \]
\end{example}

\begin{definition}
  We assume that there is an infinite set $\Locs$ of \emph{locations}.
  The set of \emph{values} is defined as $\mathbb{V}=\mathbb{Z}\cup\Locs$,
  where $\mathbb{Z}$ is the set of integers.

  The set $\mathbb{E}$
  of \emph{environments} contains bindings from variables to locations,
  decorated with a \emph{lifetime}:
  % and existing in two versions, owned and not owned:
  \[
  \mathbb{E}=\{x\to^m\ell\mid x\in\Vars,\ m\in\Lifetimes\text{ and }\ \ell\in\Locs\}
  %\underbrace{\left\{x\Rightarrow^m\ell\left|\begin{array}{l}
  %x\in\Vars,\ m\in\Lifetimes\\
  %\text{and }\ell\in\Locs
  %\end{array}\right.\right\}}_{\text{owned bindings}}
  %\cup
  %\underbrace{\left\{x\rightarrow^m\ell\left|\begin{array}{l}
  %x\in\Vars,\ m\in\Lifetimes\\
  %\text{and }\ell\in\Locs
  %\end{array}\right.\right\}}_{\text{not owned bindings}}
  \]
  with the constraint that, for each $\rho\in\mathbb{E}$, there is at most a binding for each
  given variable $x$. % (owned or not owned).
  Moreover, we write $\rho(x)=\ell$ and
  $\rho^+(x)=\ell^m$ when
  % either $x\Rightarrow^m\ell\in\rho$ or
  $x\rightarrow^m\ell\in\rho$, for some $m$.

  The set $\mathbb{H}$ of \emph{heaps} contains bindings from locations to values,
  existing in two versions, owned and not owned:
  \[
  \mathbb{H}=
  \underbrace{\{\ell\Rightarrow v\mid\ell\in\Locs\text{ and }v\in\mathbb{V}\}}_{\text{owned bindings}}
  \cup
  \underbrace{\{\ell\rightarrow v\mid\ell\in\Locs\text{ and }v\in\mathbb{V}\}}_{\text{not owned bindings}}
  \]
  with the constraint that, for each $h\in\mathbb{H}$, there is at most a binding for each
  location $\ell$ (owned or not owned). We write $h(\ell)=v$ meaning that
  either $\ell\Rightarrow v\in h$ or $\ell\rightarrow v\in h$. Given $L\subseteq\Locs$,
  we write $h|_{-L}$ meaning $h$ where the bindings for the locations in $L$
  have been removed (if any).

  The set of \emph{stores} $\mathbb{S}$ is the set of pairs
  $\mathbb{E}\times\mathbb{H}$, whose elements are written as $\rho\star h$.
  Given $s=\rho\star h\in\mathbb{S}$, we define $s(x)=\rho(x)$
  and $s^+(x)=\rho^+(x)$ for all
  $x\in\Vars$ and $s(\ell)=h(\ell)$ for all $\ell\in\Locs$.
  Given $L\subseteq\Locs$, we define $(\rho\star h)|_{-L}=\rho\star(h|_{-L})$.
\end{definition}

\begin{definition}[Locate]\label{def:locate}
  The partial function $\loc(\mathsf{w},s)$ determines the location that holds
  the value of the leftvalue $\mathsf{w}$ in $s\in\mathbb{S}$, as follows:
  \begin{align*}
    \loc(x,s) &= s(x)\\
    \loc(*\mathsf{w},s) &= \left\{\begin{array}{ll}
      s(\loc(\mathsf{w},s)) & \text{if } s(\loc(\mathsf{w},s)) \in \Locs\\
      \text{undefined} & \text{otherwise}
    \end{array}\right.
  \end{align*}
\end{definition}

\noindent
Note that $\loc$ is a partial function since the second case of
Def.~\ref{def:locate} is undefined when
$s(\loc(\mathsf{w},s))\not\in\Locs$. In the following, when $\loc$ is undefined, the
semantics will be stuck.


\begin{example}
  Let $\rho = \left\{x\rightarrow^m\ell_x\right\}$.
  \begin{itemize}
    \item Let $s = \rho\star h$ with
    $h = \left\{\ell_x\rightarrow\ell,\ \ell\rightarrow 1\right\}$.
    Then, $s(\loc(x,s)) = s(s(x)) = s(\rho(x)) = s(\ell_x) =
    h(\ell_x) = \ell\in\Locs$, so
    $\loc(\mathtt{*}x,s)= s(\loc(x,s)) = \ell$.
    %
    \item Let $s' = \rho\star h'$ with
    $h' = \left\{\ell_x\rightarrow 1\right\}$. Then,
    $s'(\loc(x,s')) = s'(s'(x)) = s'(\rho(x)) = s'(\ell_x) =
    h'(\ell_x) = 1 \not\in\Locs$, so $\loc(\mathtt{*}x,s')$ is undefined.
  \end{itemize}
\end{example}

%\begin{definition}[Read]
%  The partial function $\readlv(s,\mathsf{w})$ retrieves the value of
%  the leftvalue $\mathsf{w}$ in $s\in\mathbb{S}$, as follows:
%  \[
%  \readlv(s,\mathsf{w})=s(\loc(s,\mathsf{w}))
%  \]
%\end{definition}

The evaluation of a leftvalue yields the value of the leftvalue and a potentially updated heap:

\begin{definition}[Semantics of leftvalues]\label{def:semantics_leftvalues}
  Given $s=\rho\star h$, we define
  \[
  \den[\mathsf{w}]{s}=\begin{cases}
  \langle s(\loc(\mathsf{w},s)), h\rangle & \text{if the static type of $\mathsf{w}$ has copy semantics}\\
  \langle s(\loc(\mathsf{w},s)), h|_{-\loc(\mathsf{w},s)}\rangle & \text{if the static type of $\mathsf{w}$ has move semantics}
  \end{cases}
  \]
\end{definition}

\noindent
Note that the second case above makes $\mathsf{w}$ point to a dangling location, hence
$\mathsf{w}$ becomes unusable.

The evaluation of an expression yields the value of the expression and a potentially updated heap:

\begin{definition}[Semantics of expressions]\label{def:semantics_expressions}
  Given $s=\rho\star h$, we define
  \begin{align*}
    \den[i]{s}&=\langle i,h\rangle\\
    \den[\borrow\mathsf{w}]{s}&=\langle\loc(\mathsf{w},s),h\rangle\\
    \den[\mathtt{mut}\borrow\mathsf{w}]{s}&=\langle\loc(\mathsf{w},s),h\rangle\\
    \den[\mathtt{box}\ \mathsf{e}]{s}&=\langle\ell,h'\cup\{\ell\Rightarrow v\}\rangle
    & \text{where $\den[\mathsf{e}]{s}=\langle v, h'\rangle$ and $\ell$ is fresh}
  \end{align*}
  For expressions that are leftvalues, see Def.~\ref{def:semantics_leftvalues}.
\end{definition}

The set of locations reachable by following owned bindings only, and starting from a set of locations $\psi$,
is defined as follows:
%
\begin{definition}[Owned reachable locations]
  Given $\psi\subseteq\Locs$ and $h\in\mathbb{H}$, we define
  \begin{align*}
  \omega^0(\psi,h)&=\psi\\ %\{\ell'\in\Locs\mid\ell\in\psi\text{ and }\ell\Rightarrow\ell'\in h\}\\
  \omega^{i+1}(\psi,h)&=\{\ell'\in\Locs\mid\ell\in\omega^i(\psi,h)\text{ and }\ell\Rightarrow\ell'\in h\}
  \end{align*}
  and
  \[
  \omega(\psi,h)=\bigcup\limits_{i\ge 0}\omega^i(\psi,h)~.
  \]
\end{definition}

The function $\drop$ removes the owned locations reachable from a set of locations.
%
\begin{definition}[Drop]\label{def:drop}
  The function $\drop:\wp(\Locs)\times\mathbb{H}\to\mathbb{H}$ is defined as
  \[
  \drop(\psi,h)=h|_{-{\omega(\psi,h)}}~.
  \]
\end{definition}

\begin{definition}[Semantics of terms]\label{def:semantics_terms}
  Given $s=\rho\star h$ and $m\in\Lifetimes$, we define
  \begin{align*}
    \denl[\mathsf{w}=\mathsf{e}]{m}{s}&=
    \begin{cases}
      \langle\rho,h''[\ell\Rightarrow v]\rangle & \text{if the static type of $\mathsf{e}$ is a box}\\
      \langle\rho,h''[\ell\to v]\rangle & \text{if the static type of $\mathsf{e}$ is not a box}
    \end{cases}\\
    &\text{where $\den[\mathsf{e}]{s}=\langle v,h'\rangle$, $\ell=\loc(\mathsf{w},\langle\rho,h'\rangle)$ and
      $h''=\drop(\{\ell\},h')$}\\
    \denl[\mathtt{let\ mut}\ x=\mathsf{e}]{m}{s}&=
    \begin{cases}
      \langle\rho[x\to^m\ell],h'[\ell\Rightarrow v]\rangle & \text{if the static type of $\mathsf{e}$ is a box}\\
      \langle\rho[x\to^m\ell],h'[\ell\to v]\rangle & \text{if the static type of $\mathsf{e}$ is not a box}
    \end{cases}\\
    &\text{where $\den[\mathsf{e}]{s}=\langle v,h'\rangle$ and $\ell$ is fresh}\\
    \denl[\{\mathsf{t_1};\ldots;\mathsf{t_n}\}^l]{m}{s}&=\langle\rho,\drop(\{\ell\mid x\to^l\ell\in\rho'\},h')\rangle\\
    &\text{where $\langle\rho',h'\rangle=\denl[\mathsf{t_n}]{l}{\denl[\mathsf{t_{n-1}}]{l}{\cdots\denl[\mathsf{t_1}]{l}{s}}}$.}
  \end{align*}
\end{definition}

\begin{example}
  Consider again the program of Ex.~\ref{ex:program}:
  \[
    \{
      \mathtt{let\ mut}\ x = \mathtt{box}\ 0;\
      \{\mathtt{let\ mut}\ y = \mathtt{mut}\borrow x;\
      \mathtt{*}y = \mathtt{box}\ 1\}^l;\
      \mathtt{let\ mut}\ z = x
    \}^m
  \]
  \begin{itemize}
    \item Let $s_0=\emptyset \star \emptyset$.
    We have $\den[0]{s_0} = \langle 0,\emptyset\rangle$, hence
    $\den[\mathtt{box}\ 0]{s_0} =
    \langle\ell,\{\ell\Rightarrow 0\}\rangle$ where $\ell$ is fresh.
    %
    Consequently, we have
    $\denl[\mathtt{let\ mut}\ x = \mathtt{box}\ 0]{m}{s_0} =
    \langle \rho_1,\ h_1\rangle$ where
    \[\rho_1=\{x\to^m\ell_x\} \qquad
    h_1 = \{\ell_x\Rightarrow \ell,\ \ell\Rightarrow 0\}\]
    and $\ell_x$ is fresh.
    %
    \item Let $s_1 = \rho_1 \star h_1$.
    Then, we have $\den[\mathtt{mut}\borrow x]{s_1} =
    \langle\loc(x,s_1),h_1\rangle = \langle\ell_x, h_1\rangle$.
    Therefore, we have
    $\denl[\mathtt{let\ mut}\ y = \mathtt{mut}\borrow x]{l}{s_1} =
    \langle \rho_2,\ h_2\rangle$
    where
    \begin{align*}
      \rho_2 & = \rho_1[y\to^l\ell_y] = \{y\to^l\ell_y,\ x\to^m\ell_x\}\\
      h_2 & = h_1[\ell_y\to \ell_x] =
      \{\ell_y\to \ell_x,\ \ell_x\Rightarrow \ell,\ \ell\Rightarrow 0\}
    \end{align*}
    and $\ell_y$ is fresh.
    %
    \item Let $s_2 = \rho_2 \star h_2$.
    We have $\den[1]{s_2} = \langle 1,h_2\rangle$, hence
    $\den[\mathtt{box}\ 1]{s_2} =
    \langle\ell',h_2[\ell'\Rightarrow 1]\rangle$ where $\ell'$ is fresh.
    %
    If we let $s'_2=\langle\rho_2,h_2[\ell'\Rightarrow 1]\rangle$,
    we have $\loc(\mathtt{*}y,s'_2) = s'_2(\loc(y,s'_2)) =
    s'_2(s'_2(y)) = s'_2(\rho_2(y)) = s'_2(\ell_y) = h_2[\ell'\Rightarrow 1](\ell_y)
    = \ell_x$. Moreover, $h^{''}_2=\drop(\{\ell_x\},h_2[\ell'\Rightarrow 1]) =
    \{\ell_y\to \ell_x,\ell'\Rightarrow 1\}$. Consequently,
    $\denl[\mathtt{*}y = \mathtt{box}\ 1]{l}{s_2} =
    \langle\rho_3,h_3\rangle$ where
    \[\rho_3 = \rho_2
    \text{ and }
    h_3 = \{\ell_y\to\ell_x,\ell_x\Rightarrow\ell',
    \ell'\Rightarrow 1\}\]
    %
    \item Let us evaluate
    $\denl[\{\mathtt{let\ mut}\ y = \mathtt{mut}\borrow x;\
    \mathtt{*}y = \mathtt{box}\ 1\}^l]{m}{s_1}$. Above, we have
    computed $\denl[\mathtt{*}y = \mathtt{box}\ 1]{l}{
    \denl[\mathtt{let\ mut}\ y = \mathtt{mut}\borrow x]{l}{s_1}} =
    \langle\rho_3,h_3\rangle$. Moreover,
    $\drop(\{\ell\mid x\to^l\ell\in\rho_3\},h_3) = \drop(\{\ell_y\},h_3) =
    \{\ell_x\Rightarrow\ell',\ell'\Rightarrow 1\}$. Consequently,
    $\denl[\{\mathtt{let\ mut}\ y = \mathtt{mut}\borrow x;\
    \mathtt{*}y = \mathtt{box}\ 1\}^l]{m}{s_1} =
    \langle \rho_4,h_4\rangle$ where
    \[\rho_4 = \rho_1 \text{ and } h_4 = \{\ell_x\Rightarrow\ell',\ell'\Rightarrow 1\}\]
    %
    \item Let $s_4 = \rho_4 \star h_4$. Then,
    $\den[x]{s_4} =
    \langle s_4(\loc(x,s_4)), {h_4}|_{-\loc(x,s_4)}\rangle$
    with $\loc(x,s_4)=\ell_x$ and $s_4(\loc(x,s_4)) = s_4(\ell_x)
    = h_4(\ell_x)=\ell'$. So,
    $\denl[\mathtt{let\ mut}\ z = x]{m}{s_4}$
  \end{itemize}
\end{example}
