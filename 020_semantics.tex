\section{Semantics}\label{sec:semantics}

\begin{definition}
  We assume there is a set of variables $\Vars$
  and a finite set $\Lifetimes$ of \emph{lifetimes}.
  The set $\Leftvalues$ of \emph{leftvalues} is defined as:
  \begin{align*}
    \mathsf{w} ::= &\ x & \text{variable, with $x\in\Vars$}\\
    | &\ \mathtt{*}\mathsf{w} & \text{dereference}
  \end{align*}
  The set of \emph{expressions} \textsf{e} is defined as
  \begin{align*}
    \mathsf{e} ::= &\ i & \text{integer}\\
    | &\ \mathsf{w} & \text{leftvalue}\\
    | &\ \borrow\mathsf{w} & \text{borrow}\\
    | &\ \mutborrow\mathsf{w} & \text{mutable borrow}\\
    | &\ \mathtt{box}\ \mathsf{e} & \text{heap allocation}
  \end{align*}
  The sets of \emph{terms} \textsf{t} and \emph{blocks} \textsf{b}
  is defined as:
  \begin{align*}
    \mathsf{t} ::= &\ \mathsf{w}=\mathsf{e} & \text{assignment}\\
    | &\ \mathtt{let\ mut}\ x=\mathsf{e} & \text{declaration, with $x\in\Vars$}\\
    | &\ \{\mathsf{t_1};\ldots;\mathsf{t_n}\}^l & \text{block, with $n\ge 0$ and $l\in\Lifetimes$}
  \end{align*}
\end{definition}

\begin{example}\label{ex:program}
  The following valid program $P_1$ consists of a block that contains an inner block.
  \[
    \{
      \mathtt{let\ mut}\ x = \mathtt{box}\ 0;\
      \{\mathtt{let\ mut}\ y = \mutborrow x;\
      \mathtt{*}y = \mathtt{box}\ 1\}^l;\
      \mathtt{let\ mut}\ z = x
    \}^m
  \]
  \qed
\end{example}

The $*$ operator is called \emph{dereference}. In general, dereference means to access the
value bound to a reference. In Rust, borrows, mutable borrows and boxes are all references.
Hence, dereference can be used to read the value bound to a borrow, as in
\[
\{
\mathtt{let\ mut}\ x = 13;\
\mathtt{let\ mut}\ y = \borrow x;\
\mathtt{let\ mut}\ z = \mathtt{*}y
\}^l
\]
that reads the value bound to the address of $x$, hence copying $13$ into $z$.
Dereference can also be used to access the value bound to a mutable borrow, as in
\[
\{
\mathtt{let\ mut}\ x = 13;\
\mathtt{let\ mut}\ y = \mutborrow x;\
\mathtt{let\ mut}\ z = \mathtt{*}y
\}^l
\]
that, again, copies $13$ into $z$.
By using mutable borrows, one can also \emph{mutate} the referenced value, as in
\[
\{
\mathtt{let\ mut}\ x = \mathtt{box}\ 0;\
\mathtt{let\ mut}\ y = \mutborrow x;\
\mathtt{*}y = \mathtt{box}\ 1
\}^l
\]
that modifies $x$, so that it ends up being bound to a box containing $1$. Since $y$ holds a mutable borrow,
it is legal to mutate the value bound to it, which would not be the case with a non-mutable borrow.
Finally, the $*$ operator can be used to dereference a box, as in
\[
\{
\mathtt{let\ mut}\ x = \mathtt{box}\ 13;\
\mathtt{let\ mut}\ y = *x
\}^l
\]
that binds $y$ to $13$. This works for writing into a box as well:
\[
\{
\mathtt{let\ mut}\ x = \mathtt{box}\ 13;\
\mathtt{let\ mut}\ *x = 17
\}^l
\]
replaces $13$ with $17$ inside the box in $x$.

\begin{definition}[Root of leftvalues]\label{def:root}
  The \emph{root} of a leftvalue is the starting variable to which the dereferences of the
  leftvalue are applied. Namely, we define
  \begin{align*}
    \mathsf{root}(x) &= x\qquad\text{if $x\in\Vars$}\\
    \mathsf{root}(\mathtt{*}\mathsf{w}) &= \mathsf{root}(\mathsf{w}).
  \end{align*}
\end{definition}

\begin{definition}[Context]\label{def:context}
  A context $\kappa$ is a set of tags $\{x_1\to^{m_1},\ldots,x_n\to^{m_n}\}$,
  for distinct variables $x_1,\ldots,x_n$,
  meaning that the variables in scope are exactly
  $\dom(\kappa)=\{x_1,\ldots,x_n\}$, with the given lifetimes,
  with the constraint that there is at most a tag for each
  given variable.
\end{definition}

\begin{definition}[Values]\label{def:values}
  The set of \emph{values} is defined as $\mathbb{V}=\mathbb{Z}\cup\Locs$,
  where $\mathbb{Z}$ is the set of integers and
  $\Locs$ is an infinite set of \emph{locations}.
\end{definition}

\begin{definition}[Domains]\label{def:domains}
  Given a context $\kappa$, an \emph{environment} $\rho$ over $\kappa$
  is a set of bindings from variables to locations, decorated with a \emph{lifetime}:
  \[
  \rho\subseteq\{x\to^m\ell\mid x\to^m\in\kappa\text{ and }\ell\in\Locs\}
  \]
  with the constraint that exactly one binding exists for each given variable in $\dom(\kappa)$.
  The set of all environments over $\kappa$ is $\mathbb{E}_\kappa$.
  Often, to simplify the notation, we will write $\mathbb{E}$ for $\mathbb{E}_\kappa$.
  We write $\rho(x)=\ell$ when $x\to^m\ell\in\rho$, for some $m$.

  A \emph{heap} $h$ is a set of bindings from locations to values,
  existing in three versions: owned, immutable borrows and mutable borrows:
  \[
  h\subseteq
  \underbrace{\{\ell\Rightarrow v\mid\ell\in\Locs\text{ and }v\in\mathbb{V}\}}_{\text{owned bindings}}
  \cup
  \underbrace{\{\ell\to\ell'\mid\ell,\ell'\in\Locs\}}_{\text{immutable borrows}}
  \cup
  \underbrace{\{\ell\leadsto\ell'\mid\ell,\ell'\in\Locs\}}_{\text{mutable borrows}}
  \]
  with the constraint that there is at most a binding for each
  location $\ell$ (owned, immutable borrow or mutable borrow). We write $h(\ell)=v$ meaning that
  either $\ell\Rightarrow v\in h$ or $\ell\to v\in h$ or $\ell\leadsto v\in h$.
  Given $L\subseteq\Locs$,
  we write $h|_{-L}$ meaning $h$ where the bindings for the locations in $L$
  have been removed (if any).
  The set of all heaps is $\mathbb{H}$.

  The set of \emph{stores} is $\mathbb{S}_\kappa=\mathbb{E}_\kappa\times\mathbb{H}$,
  whose elements are pairs written as $\rho\star h$.
  Often, to simplify the notation, we will write $\mathbb{S}$ for $\mathbb{S}_\kappa$.
  Given $s=\rho\star h\in\mathbb{S}_\kappa$, we define $s(x)=\rho(x)$ for all
  $x\in\dom(\kappa)$, and $s(\ell)=h(\ell)$ for all $\ell\in\Locs$.
  Given $L\subseteq\Locs$, we define $(\rho\star h)|_{-L}=\rho\star(h|_{-L})$.
\end{definition}

\begin{definition}[Dangling locations]\label{def:dangling}
  Let $h\in\mathbb{H}$ and $\ell\in\Locs$. Then $\ell$ is \emph{dangling} in $h$ if
  and only if $h(\ell)$ is undefined.
\end{definition}

\begin{definition}[Borrowed locations]\label{def:borrow}
  Let $h\in\mathbb{H}$ and $\ell\in\Locs$.
  Then $\ell$ is \emph{borrowed as immutable} in $h$
  if there exists $\ell'\in\Locs$ such that $\ell'\to\ell$;
  it is \emph{borrowed as mutable} in $h$
  if there exists $\ell'\in\Locs$ such that $\ell'\leadsto\ell$;
  it is \emph{borrowed} in $h$
  if it is borrowed either as immutable or as mutable in $h$.
\end{definition}

Leftvalues are special expressions, since they are allocated at a location,
bound to the value of the leftvalue. Intuitively, the location holding the value of
\[
\underbrace{*\cdots*}_{n\text{ times}}x
\]
is determined by starting from the location of $x$ and following the arrows
($\Rightarrow$, $\to$ or $\leadsto$) from there, $n$ times. This is what happens
in Ex.~\ref{ex:write_leftvalue}, where we \emph{write} into a leftvalue.

\begin{example}\label{ex:write_leftvalue}
  Consider the following legal code:
  \[
  \{
  \mathtt{let\ mut}\ x = \mathtt{box}\ \mathtt{box}\ 13;\
  \mathtt{let\ mut}\ z = \mutborrow *x;\
  *z = \mathtt{box}\ 17
  \}^l
  \]
  In this code, the assignment to the leftvalue $*z$
  replaces the inner box, containing $13$, with another box containing $17$.
\end{example}

\noindent
The same happens in Ex.~\ref{ex:read_leftvalue}, where we \emph{read} an integer from a leftvalue.

\begin{example}\label{ex:read_leftvalue}
  Consider the following legal code:
  \[
  \{
  \mathtt{let\ mut}\ x = \mathtt{box}\ 13;\
  \mathtt{let\ mut}\ z = \borrow *x;\
  \mathtt{let\ mut}\ y = *z
  \}^l
  \]
  This code stores in $z$ the location of the box containing $13$.
  As a consequence when, at its end,
  the leftvalue $*z$ is read, its value is $13$, variable $y$ gets bound to $13$
  and $x$ remains bound to a box containing $13$.
\end{example}

\noindent
But Rust has a peculiarity: when one reads a value from a leftvalue $\mathsf{w}$, and that value has move semantics
(hence it is a box or a mutable borrow) then the computation of the location holding the value of $\mathsf{w}$
cannot pass through a borrow or a mutable borrow. For instance, the code in Ex.~\ref{ex:read_leftvalue2} is illegal.

\begin{example}\label{ex:read_leftvalue2}
  Consider the following illegal code:
  \[
    \{
      \mathtt{let\ mut}\ x = \mathtt{box}\ \mathtt{box}\ 13;\
      \mathtt{let\ mut}\ z = \mutborrow *x;\
      \mathtt{let\ mut}\ y = *z
    \}^l
    \]
    This code stores in $z$ the location $\ell$ of the inner box containing $13$.
    Then it attempts to read the value of $*z$, that is, it tries to dereference $\ell$, that would
    yield the value $\mathtt{box}\ 13$. That dereference passes through a mutable borrow and
    $\mathtt{box}\ 13$ has move semantics. As a consequence, the code is illegal and will be rejected
    by the Rust compiler.
\end{example}

Ex.~\ref{ex:read_leftvalue2} shows that a semantics of Rust must determine
if the computation of the location $\ell$ holding the value of a leftvalue, when reading that value,
passes through a borrow or a mutable borrow. Therefore, Def.~\ref{def:location_for_reading}
yields both $\ell$ and a Boolean mark.

\begin{definition}[Location for reading]\label{def:location_for_reading}
  Given $\mathsf{w}\in\Leftvalues$ and $s=\rho\star h\in\mathbb{S}$, the
  partial function $\locread(\mathsf{w},s)$ yields the location that holds
  the value of $\mathsf{w}$ and a Boolean mark that informs if the evaluation
  of $\mathsf{w}$ passes through a borrow:

  \begin{align*}
    \locread(x,s) &= \langle\rho(x),\mathit{false}\rangle\\
    \locread(*\mathsf{w},s) &= \begin{cases}
      \text{undefined} & \text{if $\locread(\mathsf{w},s)$ is undefined}\\
      \text{undefined} & \text{if $\locread(\mathsf{w},s)=\langle\ell,b\rangle$ and $h(\ell)$ is undefined}\\
      \text{undefined} & \text{if $\locread(\mathsf{w},s)=\langle\ell,b\rangle$ and $h(\ell)\in\mathbb{Z}$}\\
      \langle \ell',\mathit{true}\rangle & \text{if $\locread(\mathsf{w},s)=\langle\ell,b\rangle$ and $\ell\to\ell'\in h$}\\
      \langle \ell',\mathit{true}\rangle & \text{if $\locread(\mathsf{w},s)=\langle\ell,b\rangle$ and $\ell\leadsto\ell'\in h$}\\
      \langle \ell',b\rangle & \text{if $\locread(\mathsf{w},s)=\langle\ell,b\rangle$ and $\ell\Rightarrow\ell'\in h$.}
    \end{cases}
  \end{align*}
\end{definition}

\noindent
In many cases, the Boolean mark returned by $\locread$ is irrelevant. For instance,
Ex.~\ref{ex:write_leftvalue} shows that writing into a leftvalue is possible also when
the location of the leftvalue is determined by passing through a borrow or a mutable borrow.
Hence, the Boolean mark is not needed in that case. In such cases, it is simpler
to use a function $\loc$, that projects $\locread$ on its first component.

\begin{definition}[Location]\label{def:location}
  Given $\mathsf{w}\in\Leftvalues$ and $s=\rho\star h\in\mathbb{S}$, the
  partial function $\loc(\mathsf{w},s)$ yields the location holding the value of $\mathsf{w}$:
  \[
    \loc(\mathsf{w},s) = \begin{cases}
      \text{undefined} & \text{if $\locread(\mathsf{w},s)$ is undefined}\\
      \ell & \text{if $\locread(\mathsf{w},s)=\langle\ell,b\rangle$.}
    \end{cases}
  \]
\end{definition}

\noindent
Note that the second case of Def.~\ref{def:location_for_reading}
makes functions $\locread$ and $\loc$
undefined when the evaluation of $\mathsf{w}$ passes through something that is not
a location, that consequently cannot be dereferenced.
In the following, when the semantics
uses $\locread$ or $\loc$ and the latter is undefined, then the semantics will be stuck.

\begin{example}
  Let $\rho = \left\{x\to^m\ell_x\right\}$.
  \begin{itemize}
    \item Let $s = \rho\star h$ with
    $h = \left\{\ell_x\to\ell,\ \ell\Rightarrow 1\right\}$.
    Then, $\locread(x,s)=\langle\rho(x),\mathit{false}\rangle=
    \langle\ell_x,\mathit{false}\rangle$ with $\ell_x\to\ell\in h$.
    So, $\locread(*x,s)=\langle \ell,\mathit{true}\rangle$
    and $\loc(\mathtt{*}x,s)= \ell$.
    %
    \item Let $s' = \rho\star h'$ with
    $h' = \left\{\ell_x\Rightarrow 1\right\}$.
    Then, $\locread(x,s')=\langle\rho(x),\mathit{false}\rangle=
    \langle\ell_x,\mathit{false}\rangle$ with $h'(\ell_x)=1\in\mathbb{Z}$.
    So, $\locread(*x,s')$ is undefined, hence $\loc(\mathtt{*}x,s')$ is undefined.
    \qed
  \end{itemize}
\end{example}

\begin{definition}[Undefined leftvalues]\label{def:undefined_leftvalues}
  Let $\mathsf{w}\in\Leftvalues$ and $s=\rho\star h\in\mathbb{S}$. Then
  $\mathsf{w}$ is \emph{undefined} in $s$ if $\loc(\mathsf{w},s)$ is either undefined
  or dangling in $s$.
\end{definition}

%The notion of dangling location (Def.~\ref{def:dangling}) is lifted to leftvalues.

%\begin{definition}[Dangling leftvalues]\label{def:dangling_leftvalues}
%  Let $\mathsf{w}\in\Leftvalues$ and $s=\rho\star h\in\mathbb{S}$. Then
%  $\mathsf{w}$ is \emph{dangling} in $s$ if $\loc(\mathsf{w},s)$ is defined and is dangling in $h$.
%\end{definition}

The notion of borrowed location (Def.~\ref{def:borrow}) is lifted to leftvalues.

\begin{definition}[Borrowed leftvalues]\label{def:borrowed_leftvalues}
  Let $\mathsf{w}\in\Leftvalues$ and $s=\rho\star h\in\mathbb{S}$. Then
  $\mathsf{w}$ is \emph{borrowed as immutable} in $s$
  if $\loc(\mathsf{w},s)$ is borrowed as
  immutable in $h$. It is \emph{borrowed as mutable} in $s$ if
  $\loc(\mathsf{w},s)$ is borrowed as
  mutable in $h$. It is \emph{borrowed} in $s$
  if it is borrowed as either immutable or mutable in $s$.
\end{definition}

Reading the value of an expression is called evaluation of the expression: it
yields the value contained in the expression, a potentially updated heap
and an arrow that expresses the nature of the value: an owned value, an immutable borrow
or a mutable borrow. Def.~\ref{def:semantics_leftvalues} gives the semantics of reading from
a leftvalue, while Def.~\ref{def:semantics_expressions} gives the semantics of reading from the other
kinds of expressions.

\begin{definition}[Semantics of leftvalues]\label{def:semantics_leftvalues}
  Let $s=\rho\star h\in\mathbb{S}$ and $\mathsf{w}\in\Leftvalues$. Then
  \[
  \den[\mathsf{w}]{s}=\begin{cases}
  \text{undefined} & \text{if $\mathsf{w}$ is undefined in $s$}\\
  \text{undefined} & \text{otherwise, if $\mathsf{w}$ is borrowed as mutable in $s$}\\
  \langle v, h, \to\rangle & \text{otherwise, if $\loc(\mathsf{w},s)\to v\in h$}\\
  \langle v, h, \Rightarrow\rangle & \text{otherwise, if $\loc(\mathsf{w},s)\Rightarrow v\in h$ and $v\in\mathbb{Z}$}\\
  \langle v, h|_{-\ell}, \Rightarrow\rangle & \text{otherwise, if $\locread(\mathsf{w},s)=\langle\ell,\mathit{false}\rangle$, $\ell\Rightarrow v\in h$ and $v\not\in\mathbb{Z}$}\\
  \langle v, h|_{-\ell}, \leadsto\rangle & \text{otherwise, if $\locread(\mathsf{w},s)=\langle\ell,\mathit{false}\rangle$ and $\ell\leadsto v\in h$}\\
  \text{undefined} & \text{otherwise.}
  \end{cases}
  \]
\end{definition}

\noindent
The first case above entails that a leftvalue, whose value has been moved out, cannot be read.
The second case specifies that a leftvalue borrowed as mutable cannot be read,
since it must be considered as frozen for the duration of the borrow.
The third and fourth cases read a value with copy semantics.
The fifth and sixth cases perform a move of a value out of $\mathsf{w}$, by transforming
$\mathsf{w}$'s location into a dangling location. These two cases deal with
values with move semantics (the fifth with boxes, the sixth with mutable borrows).
As hinted in Ex.~\ref{ex:read_leftvalue2}, a value with move semantics can be read from a leftvalue
only if the evaluation of the latter does not pass through a borrow or a mutable borrow, hence the
requirement that the second component of $\locread$ is $\mathit{false}$.

\begin{definition}[Semantics of expressions]\label{def:semantics_expressions}
  Let $s=\rho\star h\in\mathbb{S}$. Then
  \begin{align*}
    \den[i]{s}&=\langle i,h,\Rightarrow\rangle\\
    \den[\borrow\mathsf{w}]{s}&=\begin{cases}
    \text{undefined} & \text{if $\mathsf{w}$ is undefined in $s$}\\
    \langle\loc(\mathsf{w},s),h,\to\rangle & \text{otherwise}
    \end{cases}\\
    \den[\mutborrow\mathsf{w}]{s}&=\begin{cases}
    \text{undefined} & \text{if $\mathsf{w}$ is undefined in $s$}\\
    \langle\loc(\mathsf{w},s),h,\leadsto\rangle & \text{otherwise}
    \end{cases}\\
    \den[\mathtt{box}\ \mathsf{e}]{s}&=
    \begin{cases}
      \text{undefined} & \text{if $\den[\mathsf{e}]{s}$ is undefined}\\
      \langle\ell,h'\cup\{\ell\Rightarrow v\},\Rightarrow\rangle & \text{if $\den[\mathsf{e}]{s}=\langle v, h',\Rightarrow\rangle$, with $\ell$ fresh}\\
      \langle\ell,h'\cup\{\ell\to v\},\Rightarrow\rangle & \text{if $\den[\mathsf{e}]{s}=\langle v, h',\to\rangle$, with $\ell$ fresh}\\
      \langle\ell,h'\cup\{\ell\leadsto v\},\Rightarrow\rangle & \text{if $\den[\mathsf{e}]{s}=\langle v, h',\leadsto\rangle$, with $\ell$ fresh.}
    \end{cases}
  \end{align*}
\end{definition}

\noindent
The third component of the semantics of expressions
(Def.~\ref{def:semantics_expressions}) states that integers (first case) and
boxes (fourth case) are owned values, while immutable borrows and mutable borrows
are considered by the second and third case, respectively. The fourth case allocates memory
in the heap, for a new box at a new fresh location $\ell$. The nature of the value of $\mathsf{e}$,
that gets boxed, is reflected in the kind of arrow used to bind $\ell$ to that value.
In any case, $\mathtt{box}\ \mathsf{e}$ is an owned value.

Def.~\ref{def:owned_reachable_locations}
defines the set of locations reachable from an initial set of locations $\psi$,
by following owned bindings only.
%
\begin{definition}[Owned reachable locations]\label{def:owned_reachable_locations}
  Given $\psi\in\wp(\Locs)$ and $h\in\mathbb{H}$, we define
  \begin{align*}
  \omega^0(\psi,h)&=\psi\\ %\{\ell'\in\Locs\mid\ell\in\psi\text{ and }\ell\Rightarrow\ell'\in h\}\\
  \omega^{i+1}(\psi,h)&=\{\ell'\in\Locs\mid\ell\in\omega^i(\psi,h)\text{ and }\ell\Rightarrow\ell'\in h\}
  \end{align*}
  and
  \[
  \omega(\psi,h)=\bigcup\limits_{i\ge 0}\omega^i(\psi,h)~.
  \]
\end{definition}

\noindent
The function $\drop$ removes from the heap the owned locations reachable from a set of locations.
%
\begin{definition}[Drop]\label{def:drop}
  The function $\drop:\wp(\Locs)\times\mathbb{H}\to\mathbb{H}$ is defined as
  \[
  \drop(\psi,h)=h|_{-{\omega(\psi,h)}}~.
  \]
\end{definition}

The execution of a term is modelled as a function that
maps pre-states to post-states.

\begin{definition}[Semantics of terms]\label{def:semantics_terms}
  Let $s=\rho\star h\in\mathbb{S}$ and $m\in\Lifetimes$. Then
  \begin{align*}
    \denl[x=\mathsf{e}]{m}{s}&=
    \begin{cases}
      \text{undefined} & \text{if $\den[\mathsf{e}]{s}$ is undefined}\\
      \text{undefined} & \text{otherwise, if $\den[\mathsf{e}]{s}=\langle\_,h',\_\rangle$}\\
      & \quad\text{and $x$ is borrowed in $\rho\star h'$}\\
      \rho\star h''[\ell\Rightarrow v] & \text{otherwise, if $\den[\mathsf{e}]{s}=\langle v,h',\Rightarrow\rangle$}\\
      \rho\star h''[\ell\leadsto v] & \text{otherwise, if $\den[\mathsf{e}]{s}=\langle v,h',\leadsto\rangle$}\\
      & \quad\text{and $v$ is not borrowed in $h'$}\\
      \rho\star h''[\ell\to v] & \text{otherwise, if $\den[\mathsf{e}]{s}=\langle v,h',\to\rangle$}\\
      & \quad\text{and $v$ is not borrowed as mutable in $h'$}\\
      \text{undefined} & \text{otherwise,}
    \end{cases}\\
    &\text{where $\ell=\loc(x,\rho\star h')$ and $h''=\drop(\ell,h')$}\\
    \mbox{}\\
    \denl[*\mathsf{w}=\mathsf{e}]{m}{s}&=
    \begin{cases}
      \text{undefined} & \text{if $\den[\mathsf{e}]{s}$ is undefined}\\
      \text{undefined} & \text{otherwise, if $\loc(\mathsf{w},\rho\star h')\leadsto\ell\not\in h$}\\
      \rho\star h''[\ell\Rightarrow v] & \text{otherwise, if $\den[\mathsf{e}]{s}=\langle v,h',\Rightarrow\rangle$}\\
      \rho\star h''[\ell\leadsto v] & \text{otherwise, if $\den[\mathsf{e}]{s}=\langle v,h',\leadsto\rangle$}\\
      & \quad\text{and $v$ is not borrowed in $h'$}\\
      \rho\star h''[\ell\to v] & \text{otherwise, if $\den[\mathsf{e}]{s}=\langle v,h',\to\rangle$}\\
      &\quad\text{and $v$ is not borrowed as mutable in $h'$}\\
      \text{undefined} & \text{otherwise,}
    \end{cases}\\
    &\text{where $\ell=\loc(*\mathsf{w},\rho\star h')$ and $h''=\drop(\{\ell\},h')$}\\
    \mbox{}\\
    \denl[\mathtt{let\ mut}\ x=\mathsf{e}]{m}{s}&=
    \begin{cases}
      \text{undefined} & \text{if $\den[\mathsf{e}]{s}$ is undefined}\\
      \rho[x\to^m\ell]\star h'[\ell\Rightarrow v] & \text{otherwise, if $\den[\mathsf{e}]{s}=\langle v,h',\Rightarrow\rangle$}\\
      \rho[x\to^m\ell]\star h'[\ell\leadsto v] & \text{otherwise, if $\den[\mathsf{e}]{s}=\langle v,h',\leadsto\rangle$}\\
      & \quad\text{and $v$ is not borrowed in $h'$}\\
      \rho[x\to^m\ell]\star h'[\ell\to v] & \text{otherwise, if $\den[\mathsf{e}]{s}=\langle v,h',\to\rangle$}\\
      &\quad\text{and $v$ is not borrowed as mutable in $h'$}\\
      \text{undefined} & \text{otherwise,}
    \end{cases}\\
    &\text{where $\ell$ is fresh}\\
    \mbox{}\\
    \denl[\{\mathsf{t_1};\ldots;\mathsf{t_n}\}^l]{m}{s}&=\rho\star\drop(\{\ell\mid x\to^l\ell\in\rho'\},h')\\
    &\text{where $\rho'\star h'=\denl[\mathsf{t_n}]{l}{\denl[\mathsf{t_{n-1}}]{l}{\cdots\denl[\mathsf{t_1}]{l}{s}}}$.}
  \end{align*}
\end{definition}

\begin{example}
  Show that this is illegal:
  \[
    \{
      \mathtt{let\ mut}\ x = \mathtt{box}\ 0;\
      \mathtt{let\ mut}\ y = x;\
      \mathtt{let\ mut}\ z = \borrow x
    \}^m
  \]
\end{example}

\begin{example}
  Show that this is legal:
  \[
    \{
      \mathtt{let\ mut}\ x = \mathtt{box}\ 0;\
      \mathtt{let\ mut}\ y = \mutborrow \mathtt{*}x;\
      \mathtt{*}y = 1
    \}^m
  \]
\end{example}

\begin{example}
  Show that this is illegal:
  \[
    \{
      \mathtt{let\ mut}\ x = \mathtt{box}\ 0;\
      \mathtt{let\ mut}\ y = \mutborrow \mathtt{*}x;\
      \mathtt{*}x = 1
    \}^m
  \]
\end{example}

\begin{example}
  Show that this is legal, at the end $x$ holds $1$:
  \[
    \{
      \mathtt{let\ mut}\ x = 0;\
      \mathtt{let\ mut}\ y = \mathtt{box}(\mutborrow x);\
      \mathtt{let\ mut}\ z = \mutborrow *y;\
      **z = 1
    \}^m
  \]
\end{example}

\begin{example}
  Show that this is legal, at the end $x$ holds $0$:
  \[
    \{
    \mathtt{let\ mut}\ x = 0;\
    \mathtt{let\ mut}\ k = 1;\
    \mathtt{let\ mut}\ y = \mathtt{box}(\mutborrow x);\
    *y = \mutborrow k
    \}^m
  \]
\end{example}

\begin{example}
  Consider again the program $P_1$ of Ex.~\ref{ex:program}:
  \[
    \{
      \mathtt{let\ mut}\ x = \mathtt{box}\ 0;\
      \{\mathtt{let\ mut}\ y = \mutborrow x;\
      \mathtt{*}y = \mathtt{box}\ 1\}^l;\
      \mathtt{let\ mut}\ z = x
    \}^m
  \]
  \begin{itemize}
    \item Let $s_0=\emptyset \star \emptyset$.
    We have $\den[0]{s_0} = \langle 0,\emptyset\rangle$, hence
    $\den[\mathtt{box}\ 0]{s_0} =
    \langle\ell,\{\ell\to 0\}\rangle$ where $\ell$ is fresh.
    %
    Consequently, we have
    $\denl[\mathtt{let\ mut}\ x = \mathtt{box}\ 0]{m}{s_0} =
    \langle \rho_1,\ h_1\rangle$ where
    \[\rho_1=\{x\to^m\ell_x\} \qquad
    h_1 = \{\ell_x\Rightarrow \ell,\ \ell\to 0\}\]
    and $\ell_x$ is fresh.
    %
    \item Let $s_1 = \rho_1 \star h_1$.
    Then, we have $\loc(x,s_1) = \ell_x$, so
    $\den[\mutborrow x]{s_1} = \langle\ell_x, h_1\rangle$
    with $\ell_x$ not borrowed as mutable in $h_1$.
    So, we have
    $\denl[\mathtt{let\ mut}\ y = \mutborrow x]{l}{s_1} =
    \langle \rho_2,\ h_2\rangle$
    where
    \begin{align*}
      \rho_2 & = \rho_1[y\to^l\ell_y] = \{y\to^l\ell_y,\ x\to^m\ell_x\}\\
      h_2 & = h_1[\ell_y\leadsto \ell_x] =
      \{\ell_y\leadsto \ell_x,\ \ell_x\Rightarrow \ell,\ \ell\to 0\}
    \end{align*}
    and $\ell_y$ is fresh.
    %
    \item Let $s_2 = \rho_2 \star h_2$.
    We have $\den[1]{s_2} = \langle 1,h_2\rangle$, hence
    $\den[\mathtt{box}\ 1]{s_2} =
    \langle\ell',h_2[\ell'\to 1]\rangle$ where $\ell'$ is fresh.
    %
    If we let $h'_2 = h_2[\ell'\to 1]$,
    we have $\loc(y,\langle\rho_2,h'_2\rangle) = \ell_y$ and
    $s_2(\ell_y) = h_2(\ell_y) = \ell_x$.
    Moreover, $h^{''}_2=\drop(\{\ell_x\},h'_2) =
    \{\ell_y\leadsto \ell_x,\ell'\to 1\}$. Consequently,
    $\denl[\mathtt{*}y = \mathtt{box}\ 1]{l}{s_2} =
    \langle\rho_3,h_3\rangle$ where
    \[\rho_3 = \rho_2
    \text{ and }
    h_3 = \{\ell_y\leadsto\ell_x,\ell_x\Rightarrow\ell',
    \ell'\to 1\}\]
    %
    \item Let us evaluate
    $\denl[\{\mathtt{let\ mut}\ y = \mutborrow x;\
    \mathtt{*}y = \mathtt{box}\ 1\}^l]{m}{s_1}$. Above, we have
    computed $\denl[\mathtt{*}y = \mathtt{box}\ 1]{l}{
    \denl[\mathtt{let\ mut}\ y = \mutborrow x]{l}{s_1}} =
    \langle\rho_3,h_3\rangle$. Moreover,
    $\drop(\{\ell\mid x\to^l\ell\in\rho_3\},h_3) = \drop(\{\ell_y\},h_3) =
    \{\ell_x\Rightarrow\ell',\ell'\to 1\}$. Consequently,
    $\denl[\{\mathtt{let\ mut}\ y = \mutborrow x;\
    \mathtt{*}y = \mathtt{box}\ 1\}^l]{m}{s_1} =
    \langle \rho_4,h_4\rangle$ where
    \[\rho_4 = \rho_1 \text{ and } h_4 = \{\ell_x\Rightarrow\ell',\ell'\to 1\}\]
    %
    \item Let $s_4 = \rho_4 \star h_4$. We have
    $s_4(\loc(x,s_4)) = s_4(\ell_x) = h_4(\ell_x)=\ell'$ and
    $\ell'$ is not dangling in $h_4$ (because $\ell'\to 1 \in h_4$).
    As $\type(x)$ is a box, $x$ has move semantics. Consequently,
    $\den[x]{s_4} = \langle \ell', {h_4}|_{-\ell_x}\rangle$\ie
    $\den[x]{s_4} = \langle \ell', \{\ell'\to 1\} \rangle$.
    So, $\denl[\mathtt{let\ mut}\ z = x]{m}{s_4} = \langle \rho_5,h_5\rangle$
    where
    \begin{align*}
      \rho_5 & = \rho_4[z\to^m \ell_z] = \{z\to^m \ell_z,\ x\to^m\ell_x\}\\
      h_5 & = \{\ell_z\Rightarrow \ell',\ \ell'\to 1\}
    \end{align*}
    and $\ell_z$ is fresh.
  \end{itemize}
  \qed
\end{example}

\begin{example}
  Consider the following illegal program $P_2$
  that attempts to create two mutable references
  to the same piece of data in the same scope:
  \[
    \{
      \mathtt{let\ mut}\ x = 13;\
      \mathtt{let\ mut}\ y = \mutborrow x;\
      \mathtt{let\ mut}\ z = \mutborrow x
    \}^m
  \]
  \begin{itemize}
    \item Let $s_0=\emptyset \star \emptyset$.
    We have $\den[13]{s_0} = \langle 13,\emptyset\rangle$, hence
    $\denl[\mathtt{let\ mut}\ x = 13]{m}{s_0} =
    \langle \rho_1,\ h_1\rangle$ where
    \[\rho_1=\{x\to^m\ell_x\} \qquad
    h_1 = \{\ell_x\to 13\}\]
    and $\ell_x$ is fresh.
    %
    \item Let $s_1 = \rho_1 \star h_1$.
    Then, we have $\loc(x,s_1) = \ell_x$, so
    $\den[\mutborrow x]{s_1} = \langle \ell_x,h_1\rangle$
    with $\ell_x$ not borrowed as mutable in $h_1$.
    So, we have
    $\denl[\mathtt{let\ mut}\ y = \mutborrow x]{m}{s_1} =
    \langle \rho_2,\ h_2\rangle$
    where
    \begin{align*}
      \rho_2 & = \rho_1[y\to^m\ell_y] = \{y\to^m\ell_y,\ x\to^m\ell_x\}\\
      h_2 & = h_1[\ell_y\leadsto \ell_x] =
      \{\ell_y\leadsto \ell_x,\ \ell_x\to 13\}
    \end{align*}
    and $\ell_y$ is fresh.
    %
    \item Let $s_2 = \rho_2 \star h_2$.
    Then, we have $\loc(x,s_2) = \ell_x$, so
    $\den[\mutborrow x]{s_2} = \langle \ell_x,h_2\rangle$
    where $\ell_x$ is borrowed as mutable in $h_2$
    (because $\ell_y\leadsto \ell_x \in h_2$).
    So, $\denl[\mathtt{let\ mut}\ z = \mutborrow x]{m}{s_2}$
    is undefined.
  \end{itemize}
  \qed
\end{example}

\begin{example}
  Consider the following valid program $P'_2$ which is a variant
  of $P_2$ with immutable references:
  \[
    \{
      \mathtt{let\ mut}\ x = 13;\
      \mathtt{let\ mut}\ y = \borrow x;\
      \mathtt{let\ mut}\ z = \borrow x
    \}^m
  \]
  \begin{itemize}
    \item Let $s_0=\emptyset \star \emptyset$.
    We have $\den[13]{s_0} = \langle 13,\emptyset\rangle$, hence
    $\denl[\mathtt{let\ mut}\ x = 13]{m}{s_0} =
    \langle \rho_1,\ h_1\rangle$ where
    \[\rho_1=\{x\to^m\ell_x\} \qquad
    h_1 = \{\ell_x\to 13\}\]
    and $\ell_x$ is fresh.
    %
    \item Let $s_1 = \rho_1 \star h_1$.
    Then, we have $\loc(x,s_1) = \ell_x$, so
    $\den[\borrow x]{s_1} = \langle \ell_x,h_1\rangle$.
    Therefore, we have
    $\denl[\mathtt{let\ mut}\ y = \borrow x]{m}{s_1} =
    \langle \rho_2,\ h_2\rangle$
    where
    \begin{align*}
      \rho_2 & = \rho_1[y\to^m\ell_y] = \{y\to^m\ell_y,\ x\to^m\ell_x\}\\
      h_2 & = h_1[\ell_y\to \ell_x] =
      \{\ell_y\to \ell_x,\ \ell_x\to 13\}
    \end{align*}
    and $\ell_y$ is fresh.
    %
    \item Let $s_2 = \rho_2 \star h_2$.
    Then, we have $\loc(x,s_2) = \ell_x$, so
    $\den[\borrow x]{s_2} = \langle \ell_x,h_2\rangle$.
    Therefore, we have
    $\denl[\mathtt{let\ mut}\ z = \borrow x]{m}{s_2} =
    \langle \rho_3,\ h_3\rangle$
    where
    \begin{align*}
      \rho_3 & = \rho_2[z\to^m\ell_z] = \{z\to^m\ell_z,\ y\to^m\ell_y,\ x\to^m\ell_x\}\\
      h_3 & = h_2[\ell_z\to \ell_x] =
      \{\ell_z\to \ell_x,\ \ell_y\to \ell_x,\ \ell_x\to 13\}
    \end{align*}
    and $\ell_y$ is fresh.
  \end{itemize}
  \qed
\end{example}

\begin{example}
  Consider the following illegal program $P_3$
  where variable $x$ is assigned to $1$ while
  borrowed to $y$:
  \[
    \{
      \mathtt{let\ mut}\ x = 0;\
      \mathtt{let\ mut}\ y = \mutborrow x;\
      x = 1
    \}^m
  \]
  \begin{itemize}
    \item Let $s_0=\emptyset \star \emptyset$.
    We have $\den[0]{s_0} = \langle 0,\emptyset\rangle$, hence
    $\denl[\mathtt{let\ mut}\ x = 0]{m}{s_0} =
    \langle \rho_1,\ h_1\rangle$ where
    \[\rho_1=\{x\to^m\ell_x\} \qquad
    h_1 = \{\ell_x\to 0\}\]
    and $\ell_x$ is fresh.
    %
    \item Let $s_1 = \rho_1 \star h_1$.
    Then, we have $\loc(x,s_1) = \ell_x$, so
    $\den[\mutborrow x]{s_1} = \langle \ell_x,h_1\rangle$
    with $\ell_x$ not borrowed as mutable in $h_1$.
    So, we have
    $\denl[\mathtt{let\ mut}\ y = \mutborrow x]{m}{s_1} =
    \langle \rho_2,\ h_2\rangle$
    where
    \begin{align*}
      \rho_2 & = \rho_1[y\to^m\ell_y] = \{y\to^m\ell_y,\ x\to^m\ell_x\}\\
      h_2 & = h_1[\ell_y\leadsto \ell_x] =
      \{\ell_y\leadsto \ell_x,\ \ell_x\to 0\}
    \end{align*}
    and $\ell_y$ is fresh.
    %
    \item Let $s_2 = \rho_2 \star h_2$.
    Then, we have $\den[1]{s_2} = \langle 1,h'_2\rangle$ with $h'_2=h_2$.
    Moreover, $\loc(x,\langle\rho_2,h'_2\rangle) = \ell_x$ is borrowed in $h'_2$.
    Therefore, $\denl[x = 1]{m}{s_2}$ is undefined.
  \end{itemize}
  \qed
\end{example}

\begin{example}
  Consider the following valid program $P_4$
  where the first declaration of variable $x$ is
  shadowed by the second:
  \[
    \{
      \mathtt{let\ mut}\ x = 0;\
      \mathtt{let\ mut}\ x = 1
    \}^m
  \]
  \begin{itemize}
    \item Let $s_0=\emptyset \star \emptyset$.
    We have $\den[0]{s_0} = \langle 0,\emptyset\rangle$, hence
    $\denl[\mathtt{let\ mut}\ x = 0]{m}{s_0} =
    \langle \rho_1,\ h_1\rangle$ where
    \[\rho_1=\{x\to^m\ell_x\} \qquad
    h_1 = \{\ell_x\to 0\}\]
    and $\ell_x$ is fresh.
    %
    \item Let $s_1 = \rho_1 \star h_1$.
    We have $\den[1]{s_1} = \langle 1,h_1\rangle$, hence
    $\denl[\mathtt{let\ mut}\ x = 1]{m}{s_1} =
    \langle \rho_2,\ h_2\rangle$ where
    \[\rho_2=\{x\to^m\ell'_x\} \qquad
    h_2 = \{\ell_x\to 0,\ \ell'_x\to 1\}\]
    and $\ell'_x$ is fresh.
  \end{itemize}
  \qed
\end{example}

\begin{example}
  Consider the following illegal program $P_5$ that attempts to create
  a borrowed reference to variable $z$ that exists outside of its lifetime:
  {\small
  \[
    \{
      \mathtt{let\ mut}\ x = 0;\
      \mathtt{let\ mut}\ y = \mutborrow x;\
      \{\mathtt{let\ mut}\ z = 0;\ y = \mutborrow z\}^l;\
      \mathtt{let\ mut}\ w = y
    \}^m
  \]}
  \begin{itemize}
    \item Let $s_0=\emptyset \star \emptyset$.
    We have $\den[0]{s_0} = \langle 0,\emptyset\rangle$, hence
    $\denl[\mathtt{let\ mut}\ x = 0]{m}{s_0} =
    \langle \rho_1,\ h_1\rangle$ where
    \[\rho_1=\{x\to^m\ell_x\} \qquad
    h_1 = \{\ell_x\to 0\}\]
    and $\ell_x$ is fresh.
    %
    \item Let $s_1 = \rho_1 \star h_1$.
    Then, we have $\loc(x,s_1) = \ell_x$, so
    $\den[\mutborrow x]{s_1} = \langle\ell_x, h_1\rangle$
    with $\ell_x$ not borrowed as mutable in $h_1$.
    So, we have
    $\denl[\mathtt{let\ mut}\ y = \mutborrow x]{m}{s_1} =
    \langle \rho_2,\ h_2\rangle$
    where
    \begin{align*}
      \rho_2 & = \rho_1[y\to^m\ell_y] = \{y\to^m\ell_y,\ x\to^m\ell_x\}\\
      h_2 & = h_1[\ell_y\leadsto \ell_x] =
      \{\ell_y\leadsto \ell_x,\ \ell_x\to 0\}
    \end{align*}
    and $\ell_y$ is fresh.
    %
    \item Let $s_2 = \rho_2 \star h_2$.
    We have $\den[0]{s_2} = \langle 0,h_2\rangle$, hence
    $\denl[\mathtt{let\ mut}\ z = 0]{l}{s_2} =
    \langle \rho_3,\ h_3\rangle$ where
    \begin{align*}
      \rho_3 & = \rho_2[z\to^l\ell_z] =
      \{z\to^l\ell_z,\ y\to^m\ell_y,\ x\to^m\ell_x\}\\
      h_3 & = h_2[\ell_z\to 0] =
      \{\ell_z\to 0,\ \ell_y\leadsto \ell_x,\ \ell_x\to 0\}
    \end{align*}
    and $\ell_z$ is fresh.
    %
    \item Let $s_3 = \rho_3 \star h_3$.
    Then, we have $\loc(z,s_3) = \ell_z$, so
    $\den[\mutborrow z]{s_3} = \langle\ell_z, h'_3\rangle$
    with $h'_3=h_3$ and $\ell_z$ is not borrowed as mutable in $h'_3$.
    Moreover, $\loc(y,\langle \rho_3,h'_3\rangle) = \ell_y$ is not
    borrowed in $h'_3$
    and $\drop(\{\ell_y\},h'_3) =
    \{\ell_z\to 0,\ell_x\to 0\}$. Consequently,
    $\denl[y = \mutborrow z]{l}{s_3} = \langle \rho_4,\ h_4\rangle$
    where
    \[\rho_4=\rho_3 \text{ and }
    h_4=\{\ell_y\leadsto\ell_z,\ \ell_z\to 0,\ \ell_x\to 0\}\]
    %
    \item Let us evaluate
    $\denl[\{\mathtt{let\ mut}\ z = 0;\ y = \mutborrow z\}^l]{m}{s_2}$.
    Above, we have computed $\denl[y = \mutborrow z]{l}{
    \denl[\mathtt{let\ mut}\ z = 0]{l}{s_2}} = \langle\rho_4,h_4\rangle$.
    Moreover, we also have
    $\drop(\{\ell\mid x\to^l\ell\in\rho_4\},h_4) = \drop(\{\ell_z\},h_4) =
    \{\ell_y\leadsto\ell_z,\ \ell_x\to 0\}$. Consequently,
    $\denl[\{\mathtt{let\ mut}\ z = 0;\ y = \mutborrow z\}^l]{m}{s_2} =
    \langle \rho_5,h_5\rangle$ where
    \[\rho_5 = \rho_2 \text{ and }
    h_5 = \{\ell_y\leadsto\ell_z,\ \ell_x\to 0\}\]
    %
    \item Let $s_5 = \rho_5 \star h_5$.
    We have $s_5(\loc(y,s_5)) = s_5(\ell_y) = h_5(\ell_y) = \ell_z$
    and $\ell_z$ is dangling in $h_5$. Therefore, $\den[y]{s_5}$
    is undefined. So,
    $\denl[\mathtt{let\ mut}\ w = y]{m}{s_5}$ is undefined.
  \end{itemize}
  \qed
\end{example}

\begin{example}\label{ex:program-reborrow-valid}
  Consider the following valid program $P_6$:
  \[
    \{
      \mathtt{let\ mut}\ x = 0;\
      \{
        \mathtt{let\ mut}\ y = \mutborrow x;\
        \{
          \mathtt{let\ mut}\ z = \borrow*y
        \}^l;\
        *y = 1
      \}^n
    \}^m
  \]
  \begin{itemize}
    \item Let $s_0=\emptyset \star \emptyset$.
    We have $\den[0]{s_0} = \langle 0,\emptyset\rangle$, hence
    $\denl[\mathtt{let\ mut}\ x = 0]{m}{s_0} =
    \langle \rho_1,\ h_1\rangle$ where
    \[\rho_1=\{x\to^m\ell_x\} \qquad
    h_1 = \{\ell_x\to 0\}\]
    and $\ell_x$ is fresh.
    %
    \item Let $s_1 = \rho_1 \star h_1$.
    Then, we have $\loc(x,s_1) = \ell_x$, so
    $\den[\mutborrow x]{s_1} = \langle\ell_x, h_1\rangle$
    with $\ell_x$ not borrowed as mutable in $h_1$.
    So, we have
    $\denl[\mathtt{let\ mut}\ y = \mutborrow x]{n}{s_1} =
    \langle \rho_2,\ h_2\rangle$
    where
    \begin{align*}
      \rho_2 & = \rho_1[y\to^n\ell_y] = \{y\to^n\ell_y,\ x\to^m\ell_x\}\\
      h_2 & = h_1[\ell_y\leadsto \ell_x] =
      \{\ell_y\leadsto \ell_x,\ \ell_x\to 0\}
    \end{align*}
    and $\ell_y$ is fresh.
    \item Let $s_2 = \rho_2 \star h_2$.
    We have $\loc(*y,s_2) = s_2(\loc(y,s_2)) = s_2(\ell_y) = h_2(\ell_y) = \ell_x$,
    so $\den[\borrow*y]{s_2} = \langle \ell_x,h_2\rangle$.
    Moreover, $\type(\borrow*y)$ is not a box nor a $\mutborrow$, so
    $\denl[\mathtt{let\ mut}\ z = \borrow*y]{l}{s_2} =
    \langle \rho_3,\ h_3\rangle$
    where
    \begin{align*}
      \rho_3 & = \rho_2[z\to^l\ell_z] = \{z\to^l\ell_z,\ y\to^n\ell_y,\ x\to^m\ell_x\}\\
      h_3 & = h_2[\ell_z\to \ell_x] =
      \{\ell_z\to \ell_x,\ \ell_y\leadsto \ell_x,\ \ell_x\to 0\}
    \end{align*}
    and $\ell_z$ is fresh.
    \item Let us evaluate $\denl[\{\mathtt{let\ mut}\ z = \borrow*y\}^l]{n}{s_2}$.
    Above, we have computed $\denl[\mathtt{let\ mut}\ z = \borrow*y]{l}{s_2} =
    \langle \rho_3,\ h_3\rangle$. Moreover,
    $\drop(\{\ell\mid x\to^l\ell\in\rho_3\},h_3) = \drop(\{\ell_z\},h_3) =
    \{\ell_y\leadsto \ell_x,\ \ell_x\to 0\}$. Hence,
    $\denl[\{\mathtt{let\ mut}\ z = \borrow*y\}^l]{n}{s_2}=\langle \rho_4,\ h_4\rangle$
    where
    \[\rho_4 = \rho_2 \text{ and } h_4 = \{\ell_y\leadsto \ell_x,\ \ell_x\to 0\}\]
    \item Let $s_4 = \rho_4 \star h_4$.
    We have $\den[1]{s_4} = \langle 1,h_4\rangle$. Moreover,
    $\loc(y,s_4) = \ell_y$, $s_4(\ell_y) = h_4(\ell_y) = \ell_x$ and
    $\drop(\{\ell_x\}, h_4) = \{\ell_y\leadsto \ell_x\}$. Therefore,
    $\denl[*y = 1]{n}{s_4}=\langle \rho_5,\ h_5\rangle$ where
    \[\rho_5 = \rho_4 \text{ and } h_5 = \{\ell_y\leadsto \ell_x,\ \ell_x\to 1\}\]
    \item Let us evaluate $\denl[\{\mathtt{let\ mut}\ y = \mutborrow x;\
    \{ \mathtt{let\ mut}\ z = \borrow*y \}^l;\ *y = 1 \}^n]{m}{s_1}$.
    Above, we have computed
    \[\denl[*y = 1]{n}{
      \denl[\{\mathtt{let\ mut}\ z = \borrow*y\}^l]{n}{
        \denl[\mathtt{let\ mut}\ y = \mutborrow x]{n}{s_1}
      } = \langle \rho_5,\ h_5\rangle
    }\]
    Moreover, $\drop(\{\ell\mid x\to^n\ell\in\rho_5\},h_5) =
    \drop(\{\ell_y\},h_5) = \{\ell_x\to 1\}$. So,
    $\denl[\{\mathtt{let\ mut}\ y = \mutborrow x;\
    \{ \mathtt{let\ mut}\ z = \borrow*y \}^l;\ *y = 1 \}^n]{m}{s_1} =
    \langle \{x\to^m\ell_x\},\ \{\ell_x\to 1\}\rangle$.
  \end{itemize}
  \qed
\end{example}

\begin{example}
  Consider the following program $P'_6$ which is a variant of $P_6$:
  \[
  \{
    \mathtt{let\ mut}\ x = 0;\
    \{
      \mathtt{let\ mut}\ y = \mutborrow x;\
        \{
          \mathtt{let\ mut}\ z = \borrow*y;\
          *y = 1
        \}^l
      \}^n
    \}^m
  \]
  $P'_6$ is illegal because the immutable reborrow $\borrow *y$ in the inner
  block prohibits the writing $*y = 1$ in this block.
  \begin{itemize}
    \item Let $s_0=\emptyset \star \emptyset$.
    We have $\den[0]{s_0} = \langle 0,\emptyset\rangle$, hence
    $\denl[\mathtt{let\ mut}\ x = 0]{m}{s_0} =
    \langle \rho_1,\ h_1\rangle$ where
    \[\rho_1=\{x\to^m\ell_x\} \qquad
    h_1 = \{\ell_x\to 0\}\]
    and $\ell_x$ is fresh.
    %
    \item Let $s_1 = \rho_1 \star h_1$.
    Then, we have $\loc(x,s_1) = \ell_x$, so
    $\den[\mutborrow x]{s_1} = \langle\ell_x, h_1\rangle$
    with $\ell_x$ not borrowed as mutable in $h_1$.
    So, we have
    $\denl[\mathtt{let\ mut}\ y = \mutborrow x]{n}{s_1} =
    \langle \rho_2,\ h_2\rangle$
    where
    \begin{align*}
      \rho_2 & = \rho_1[y\to^n\ell_y] = \{y\to^n\ell_y,\ x\to^m\ell_x\}\\
      h_2 & = h_1[\ell_y\leadsto \ell_x] =
      \{\ell_y\leadsto \ell_x,\ \ell_x\to 0\}
    \end{align*}
    and $\ell_y$ is fresh.
    \item Let $s_2 = \rho_2 \star h_2$.
    We have $\loc(*y,s_2) = s_2(\loc(y,s_2)) = s_2(\ell_y) = h_2(\ell_y) = \ell_x$,
    so $\den[\borrow*y]{s_2} = \langle \ell_x,h_2\rangle$.
    Moreover, $\type(\borrow*y)$ is not a box nor a $\mutborrow$, so
    $\denl[\mathtt{let\ mut}\ z = \borrow*y]{l}{s_2} =
    \langle \rho_3,\ h_3\rangle$
    where
    \begin{align*}
      \rho_3 & = \rho_2[z\to^l\ell_z] = \{z\to^l\ell_z,\ y\to^n\ell_y,\ x\to^m\ell_x\}\\
      h_3 & = h_2[\ell_z\to \ell_x] =
      \{\ell_z\to \ell_x,\ \ell_y\leadsto \ell_x,\ \ell_x\to 0\}
    \end{align*}
    and $\ell_z$ is fresh.
    \item Let $s_3 = \rho_3 \star h_3$.
    We have $\den[1]{s_3} = \langle 1,h_3\rangle$. Moreover,
    $\loc(y,s_3) = \ell_y$ and $s_3(\ell_y) = h_3(\ell_y) = \ell_x$
    is borrowed as immutable in $h_3$ (because $\ell_z\to \ell_x \in h_3$).
    Therefore, $\denl[*y = 1]{n}{s_3}$ is undefined.
  \end{itemize}
  \qed
\end{example}
