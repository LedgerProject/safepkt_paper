\section{The Borrow Checker}\label{sec:borrow_checker}

The borrow checker has been formalized as a type system whose rules
map the typing $\tau$ before the evaluation of a syntactical object $s$ to
the typing $\tau'$ resulting after that evaluation.
We write this as $\tau\vdash s\dashv\tau'$.
For expressions, the typing
rules provide the inferred type $T$ of the expression as well:
$\tau\vdash e:T\dashv\tau'$.

Let us start from the typing rules for expressions.

\underline{\textsf{T-Const}}.
This rule applies to integer constants. Their evaluation
yields a value of type $\mathsf{int}$ and does not modify the typing:
\[
\frac
    {}
    {\tau\vdash i:\mathsf{int}\dashv\tau}
\]

\underline{\textsf{T-Copy}}.
The first rule for leftvalues applies to those leftvalues whose type
has copy semantics. Their evaluation yields their value
and the typing remains unchanged. The rule requires that the leftvalue
can be accessed for reading:
\[
\frac
    {T=\type(\mathsf{w},\tau)\quad\copytype(T)\quad\neg\mathsf{readProhibited}(\mathsf{w},\tau)}
    {\tau\vdash\mathsf{w}:T\dashv\tau}
\]

\underline{\textsf{T-Move}}.
The second rule for leftvalues applies to those leftvalues whose type
has move semantics. Their evaluation yields their value,
but its ownership is moved away from the leftvalue. Because of this,
the typing gets modified, by letting the old container of the value
get the $\mathsf{dangling}$ type (it cannot be used anymore).
As a consequence, reading, from a leftvalue, a value with move semantics
amounts to writing into its old container and requires write permission:
\[
\frac
    {T=\type(\mathsf{w},\tau)\quad\movetype(T)\quad\neg\mathsf{writeProhibited}(\mathsf{w},\tau)}
    {\tau\vdash\mathsf{w}:T\dashv\mathsf{move}(\mathsf{w},\tau)}
\]
where the $\mathsf{move}$ function
modifies the binding for the root of $\mathsf{w}$:
\[
\mathsf{move}(\mathsf{w},\tau)=\tau[\mathsf{root}(\mathsf{w})\mapsto
  \mathsf{strike}(\mathsf{w},\tau(\mathsf{root}(\mathsf{w})))]
\]
with
\begin{align*}
  \mathsf{strike}(x,T)&=\mathsf{dangling}\\
  \mathsf{strike}(\mathtt{*}\mathsf{w},\boxtype{T})&=
  \boxtype{\mathsf{strike}(\mathsf{w},T)}.
\end{align*}
The function $\mathsf{strike}$ is undefined otherwise.

\underline{\textsf{T-ImmBorrow}}.
The evaluation of the borrow expression requires the borrowed leftvalue
to be readable and have full type
(only value with full type can be borrowed in Rust):
\[
\frac
    {\mathsf{full}(\type(\mathsf{w},\tau))\quad\neg\mathsf{readProhibited}(\mathsf{w},\tau)}
    {\tau\vdash\borrow\mathsf{w}:\borrow\mathsf{w}\dashv\tau}
\]

\underline{\textsf{T-MutBorrow}}.
The evaluation of the mutable borrow expression requires the borrowed
leftvalue to be writable and have full type
(only value with full type can be borrowed in Rust). Moreover, Rust requires that
the borrowed leftvalue never traverses an immutable borrow:
\[
\frac
    {\mathsf{full}(\type(\mathsf{w},\tau))\quad\neg\mathsf{writeProhibited}(\mathsf{w},\tau)
    \quad\mathsf{mutable}(\mathsf{w},\tau(\mathsf{root}(\mathsf{w})),\tau)}
    {\tau\vdash\mutborrow\mathsf{w}:\mutborrow\mathsf{w}\dashv\tau}
\]
where
\begin{align*}
  \mathsf{mutable}(x,T,\tau)&=\mathit{true}\\
  \mathsf{mutable}(\mathtt{*}\mathsf{w},\boxtype{T},\tau)&=\mathsf{mutable}(\mathsf{w},T,\tau)\\
  \mathsf{mutable}(\mathtt{*}\underbrace{\mathtt{*}\cdots\mathtt{*}}_nx,
  \mutborrow\mathsf{w},\tau)&=\mathsf{mutable}(\underbrace{\mathtt{*}\cdots\mathtt{*}}_n\mathsf{w},
  \tau(\mathsf{root}(\mathsf{w})),\tau)
\end{align*}

\underline{\textsf{T-Box}}.
The evaluation of the box expression simply recurs on the boxed expression:
\[
\frac
    {\tau\vdash\mathsf{e}:T\dashv\tau'}
    {\tau\vdash\mathtt{box}\ \mathsf{e}:\boxtype{T}\dashv\tau'}
\]

Let us consider the typing rules for the terms now.

\underline{\textsf{T-Block}}.
The execution of a block of statements simply recurs on each single statement.
At the end, the variables $S$ declared inside the block get dropped away. We assume
that variables cannot be redefined inside a block, hence there is no risk of name clash.
\[
\frac
    {\tau\vdash\mathsf{t}_1\dashv\tau_1\quad\ldots\quad\tau_{n-1}\vdash\mathsf{t}_n\dashv\tau'
    \quad S=\{v\in\Vars\mid v\text{ is declared in }\mathsf{t}_1;\ldots;\mathsf{t}_n\}}
    {\tau\vdash\{\mathsf{t}_1;\ldots;\mathsf{t}_n\}\dashv\mathsf{drop}(S,\tau')}
\]
where
\[
\mathsf{drop}(S,\tau)=\tau|_{-S}.
\]

\underline{\textsf{T-Declare}}.
The declaration of a fresh new variable $x$ evaluates its initialization expression $\mathsf{e}$ and
binds it to $x$:
\[
\frac
    {x\not\in\dom(\tau)\quad\tau\vdash\mathsf{e}:T\dashv\tau'}
    {\tau\vdash\mathtt{let\ mut}\ x=\mathsf{e}\dashv\tau'[x\to T]}
\]

\underline{\textsf{T-Assign}}.
The assignment of a value to a leftvalue $\mathsf{w}$ requires the variable to be writable.
In that case, the assigned expression is evaluated and assigned to $\mathsf{w}$.
This is modelled through a $\mathsf{write}$ function below.
Since $\mathsf{w}$ might be more complex than a single variable, the assignment might actually
update a variable mutably borrowed reachable from the root of $\mathsf{w}$. This is reflected
in the (rather complex) definition of $\mathsf{write}$ below, that we take from~\cite{Pearce21}
where more details can be found:
\[
\frac
    {\tau\vdash\mathsf{e}:T\dashv\tau' \quad
      \tau''=\mathsf{write}(\tau',\mathsf{w},T,\mathit{strong}) \quad
      \neg\mathsf{writeProhibited}(\tau'',\mathsf{w})}
    {\tau\vdash\mathsf{w}=\mathsf{e}\dashv\tau''}
\]
where
\[
\mathsf{write}(\tau,\underbrace{\mathtt{*}\cdots\mathtt{*}}_nx,T,\mathit{modality})=\mathsf{apply}
(x,\update(\tau,n,\tau(x),T,\mathit{modality}))
\]
%
where
%
\begin{align*}
  \update(\tau,0,T',T,\mathit{strong})&=\langle\tau,T\rangle\\
  \update(\tau,0,T',T,\mathit{weak})&=\langle\tau,T'\sqcup T\rangle\\
  \update(\tau,n+1,\boxtype{T'},T,\mathit{modality})
  &=\mathsf{expand}(\update(\tau,n,T',T,\mathit{modality}))\\
  \update(\tau,n+1,\mutborrow\mathsf{w},T,\_)&=
  \langle\mathsf{write}(\tau,\underbrace{\mathtt{*}\cdots\mathtt{*}}_n\mathsf{w},T,\mathit{weak}),
  \mutborrow\mathsf{w}\rangle
\end{align*}
and
\begin{align*}
  \mathsf{apply}(y,\langle\tau,T\rangle)&=\tau[y\to T]\\
  \mathsf{expand}(\langle\tau,T\rangle)&=\langle\tau,\boxtype{T}\rangle.
\end{align*}
%
\noindent
It is important to observe that $\mathsf{write}$
can either completely replace the type of $x$
(\emph{strong} update) or modify the previous type of variables
inside the mutable borrows in $\tau$ (\emph{weak} update).
No other variable can see its type updated.

