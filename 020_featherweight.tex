\section{Simplified Featherweight Rust}\label{sec:featherweight}

This section gives a formal, simplified presentation of Featherweight
Rust~\cite{Pearce21}. The simplifications make the language and its
borrow checker (Sec.~\ref{sec:borrow_checker})
more amenable to formal proofs, by focusing on the way borrows work. Namely:
%
\begin{itemize}
\item We have used a dangling type that does not embed the
  original, \emph{ghost} type as is the case in~\cite{Pearce21}.
  That information is important to ensure that a variable, whose value has been
  previously moved away, is subsequently reassigned a value compatible
  with its original type. However, this is irrelevant here,
  since it is related to traditional type checking and not to borrow checking.
\item We have restricted borrow types to a single leftvalue, rather than to a set of
  leftvalues as in~\cite{Pearce21}. By using a set, \cite{Pearce21}
  was ready for the addition of conditional control. However, this just makes definitions
  and proofs more complex, without adding anything significant \wrt the way borrows work.
\item We have transformed some definitions, originally given as typing rules in~\cite{Pearce21},
  to the definition of functions, such as functions $\mathsf{type}$ and $\mathsf{move}$ later.
  This makes them more compact and simplifies proofs involving them.
\end{itemize}

\begin{definition}
  We assume there is a set of variables $\Vars$.
  A context $\kappa\subseteq\Vars$ is a finite set of variables in scope.
  The set $\Leftvalues_\kappa$ of \emph{leftvalues} over $\kappa$ is defined as:
  \begin{align*}
    \mathsf{w} ::= &\ x & \text{variable, with $x\in\kappa$}\\
    | &\ \mathtt{*}\mathsf{w} & \text{dereference.}
  \end{align*}
  The \emph{root} of a leftvalue is the starting variable to which the dereferences of the
  leftvalue are applied. Namely, we define
  \begin{align*}
    \mathsf{root}(x) &= x\qquad\text{if $x\in\Vars$}\\
    \mathsf{root}(\mathtt{*}\mathsf{w}) &= \mathsf{root}(\mathsf{w}).
  \end{align*}
  The set of \emph{expressions} \textsf{e} is defined as
  \begin{align*}
    \mathsf{e} ::= &\ i & \text{integer}\\
    | &\ \mathsf{w} & \text{leftvalue}\\
    | &\ \borrow\mathsf{w} & \text{borrow}\\
    | &\ \mutborrow\mathsf{w} & \text{mutable borrow}\\
    | &\ \mathtt{box}\ \mathsf{e} & \text{heap allocation.}
  \end{align*}
  We assume there is a set $\Lifetimes$ of \emph{lifetimes}, used
  to decorate blocks of code.
  The sets of \emph{terms} \textsf{t} is defined as:
  \begin{align*}
    \mathsf{t} ::= &\ \mathsf{w}=\mathsf{e} & \text{assignment}\\
    | &\ \mathtt{let\ mut}\ x=\mathsf{e} & \text{declaration, with $x\in\Vars$}\\
    | &\ \{\mathsf{t}_1;\ldots;\mathsf{t}_n\}^l & \text{block, with $l\in\Lifetimes$.}
  \end{align*}
\end{definition}
%
Intuitively, the variables declared in a block with lifetime $l$ receive lifetime $l$
and go out of scope and are deallocated
at the end of the block. Lifetimes are important for the borrow checker,
in order to check that borrowed variables do not survive their declaring block, since in that
case the borrows would become dangling.

The types used by the borrow checker are somehow non-standard, in the sense
that they describe primitive types (such as $\mathsf{int}$) or structures
dynamically allocated in memory (collectively represented by a box), but can also refer to
a borrow or mutable borrow of a leftvalue.
This is a simplification of the types from~\cite{Pearce21}, that allow more leftvalues
in borrows. Since our simplified language has no conditionals, there is no need for
more than one leftvalue in borrows.

Moreover, a type can state that the value of a variable
has been \emph{moved}, that is, assigned
to another owner, that takes control of its ownership.
Consequently, the value exists but cannot be accessed from that variable anymore.
We write this as $\mathsf{dangling}$\footnote{This is a simplification of the
$\mathsf{dangling}(T)$ type in~\cite{Pearce21}, that embeds
the \emph{ghost} type $T$ of a value that has been moved away.}.

\begin{definition}[Types]
  The set of \emph{types} over a context $\kappa$
  is\footnote{The types for borrows and mutable borrows are restricted to a single leftvalue,
    while~\cite{Pearce21} allows one or more leftvalues.}
  \begin{align*}
    \mathsf{T}_\kappa ::=&\ \mathsf{int} & \text{integer}\\
    | &\ \borrow\mathsf{w} & \text{borrow, with $\mathsf{w}\in\mathsf{T}_\kappa$}\\
    | &\ \mutborrow\mathsf{w} & \text{mutable borrow, with $\mathsf{w}\in\mathsf{T}_\kappa$}\\
    | &\ \boxtype{\mathsf{T}_\kappa} & \text{box}\\
    | &\ \mathsf{dangling} & \text{dangling}.
  \end{align*}
  The set of \emph{decorated types} over $\kappa$ contains types with an
  associated lifetime, such as $T^l$. We define $|T^l|=T$.
\end{definition}

Rust distinguishes between types with copy semantics
and types with move semantics.
Values whose type has copy semantics
are copied upon reading, while values whose type has
move semantics are \emph{moved} instead, in the sense that their original container
loses the ownership to the value. Only mutable borrows and dynamically
allocated data (hence boxes) have move semantics.

\begin{definition}[Copy and move types]\label{def:copy_move}
  Let $T\in\mathsf{T}_\kappa$. Then $T$ \emph{has move semantics}, and we write
  $\movetype(T)$, if and only if $T=\mutborrow\mathsf{w}$ or
  $T=\boxtype{T'}$ for some $T'$. In all other cases, $T$ \emph{has copy semantics},
  and we write $\copytype(T)$.
\end{definition}

Another useful notion is that of \emph{full} types. They are types that do not contain
$\mathsf{dangling}$. This notion is important because, as we will see
in Sec.~\ref{sec:borrow_checker}, only values with full type can be borrowed in Rust.

\begin{definition}[Full type]\label{def:full}
  A type $T\in\mathsf{T}_\kappa$ is \emph{full}
  if and only if $\mathsf{dangling}$ does not occur inside $T$.
  We write it as $\mathsf{full}(T)$.
\end{definition}

We can now define the typings, or type environments, that is,
information about the types of the variables in scope at a given program point,
with their lifetime.

\begin{definition}[Typing]\label{def:typing}
  Given a context $\kappa$, a \emph{typing} $\tau$ over $\kappa$ is
  a map from each variable $v\in\kappa$ to a type $T$ and a lifetime $l$.
  We write this as $\tau(v)=T^l$.
\end{definition}

The types used in a typing can include borrows and mutable borrows.
The basic idea of the borrow checker is that the root of the
borrowed leftvalues (mutable or not) can only be used
in a restricted way~\cite{Pearce21}.

\begin{definition}[Read/Write Prohibited]\label{def:prohibited}
  Let $\kappa$ be a context and $\tau$ a \emph{typing} over $\kappa$.
  Then $\mathsf{w}\in\Leftvalues_\kappa$ is
  \emph{read prohibited in $\tau$},
  written as $\mathsf{readProhibited}(\mathsf{w},\tau)$,
  if $\mathsf{root}(\mathsf{w})$ occurs in a mutable borrow inside $\tau$.
  Moreover, $\mathsf{w}$ is \emph{write prohibited in $\tau$}, written
  as $\mathsf{writeProhibited}(\mathsf{w},\tau)$,
  if $\mathsf{root}(\mathsf{w})$ occurs in a borrow or in a
  mutable borrow inside $\tau$.
\end{definition}

\noindent
It follows that $\mathsf{readProhibited}(\mathsf{w},\tau)$ entails
$\mathsf{writeProhibited}(\mathsf{w},\tau)$.

Def.~\ref{def:type} shows how a typing provides type and lifetime not just to variables,
but to leftvalues as well.
It is a translation\footnote{This definition was given as a type system in~\cite{Pearce21}, while it is a recursive function here.} of
Def.~3.11 in~\cite{Pearce21}.
It can be seen as a recursive algorithm for typing leftvalues
and, as such, it is heavily used in the borrow checker.
The algorithm queries the typing when the leftvalue is actually a variable,
and dereferences borrows and boxes when the leftvalue contains one or more
\<*> operations, further recurring in the case of borrows.
Types $\mathsf{int}$ and $\mathsf{dangling}$ cannot be dereferenced, hence the
algorithm fails on them.

\begin{definition}[Type of leftvalues]\label{def:type}
  Given a context $\kappa$, a typing $\tau$ over $\kappa$
  and $\mathsf{w}\in\Leftvalues_\kappa$, the partial function
  $\type(\mathsf{w},\tau)$ yields type and lifetime of $\mathsf{w}$ in $\tau$:
  \begin{align*}
    \type(x,\tau)&=\tau(x)\\
    \type(*\mathsf{w},\tau)&=\begin{cases}
    \text{undefined} & \text{if $\type(\mathsf{w},\tau)$ is undefined}\\
    \text{undefined} & \text{if $|\type(\mathsf{w},\tau)|=\mathsf{dangling}$}\\
    \text{undefined} & \text{if $|\type(\mathsf{w},\tau)|=\mathsf{int}$}\\
    \type(\mathsf{w}',\tau) & \text{if $|\type(\mathsf{w},\tau)|=\borrow\mathsf{w}'$}\\
    \type(\mathsf{w}',\tau) & \text{if $|\type(\mathsf{w},\tau)|=\mutborrow\mathsf{w}'$}\\
    T^l & \text{if $\type(\mathsf{w},\tau)=(\boxtype{T})^l$.}
    \end{cases}
  \end{align*}
\end{definition}

Def.~\ref{def:type} is clearly recursive, both on the structure of $\mathsf{w}$ and
on the leftvalues contained in the borrows or mutable borrows that occur in the typing.
In general, that recursion is not well-founded. In algorithmic terms, this means
that this algorithm for typing leftvalues might not terminate.
Consider for instance the typing $\{x\to\borrow\mathtt{*}x\}$:
the definition of $\type(\mathtt{*}x,\tau)$ ends in an infinite loop.
This example can be arbitrarily complicated, through the
use of more involved cycles that pass through more variables. As a consequence,
the natural question is to understand when the recursion in
Def.~\ref{def:type} is well-founded and if that is always the case when it is
used by the borrow checker of Rust.
