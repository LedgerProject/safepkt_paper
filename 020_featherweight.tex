\section{Simplified Featherweight Rust}\label{sec:featherweight}

This section gives a formal, simplified presentation of Featherweight
Rust~\cite{Pearce21}.

\begin{definition}
  We assume there is a set of variables $\Vars$.
  A context $\kappa\subseteq\Vars$ is a finite set of variables in scope.
  The set $\Leftvalues_\kappa$ of \emph{leftvalues} over $\kappa$ is defined as:
  \begin{align*}
    \mathsf{w} ::= &\ x & \text{variable, with $x\in\kappa$}\\
    | &\ \mathtt{*}\mathsf{w} & \text{dereference.}
  \end{align*}
  The \emph{root} of a leftvalue is the starting variable to which the dereferences of the
  leftvalue are applied. Namely, we define
  \begin{align*}
    \mathsf{root}(x) &= x\qquad\text{if $x\in\Vars$}\\
    \mathsf{root}(\mathtt{*}\mathsf{w}) &= \mathsf{root}(\mathsf{w}).
  \end{align*}
  The set of \emph{expressions} \textsf{e} is defined as
  \begin{align*}
    \mathsf{e} ::= &\ i & \text{integer}\\
    | &\ \mathsf{w} & \text{leftvalue}\\
    | &\ \borrow\mathsf{w} & \text{borrow}\\
    | &\ \mutborrow\mathsf{w} & \text{mutable borrow}\\
    | &\ \mathtt{box}\ \mathsf{e} & \text{heap allocation.}
  \end{align*}
  The sets of \emph{terms} \textsf{t} and \emph{blocks} \textsf{b} is defined as:
  \begin{align*}
    \mathsf{t} ::= &\ \mathsf{w}=\mathsf{e} & \text{assignment}\\
    | &\ \mathtt{let\ mut}\ x=\mathsf{e} & \text{declaration, with $x\in\Vars$}\\
    | &\ \{\mathsf{t}_1;\ldots;\mathsf{t}_n\} & \text{block.}
  \end{align*}
\end{definition}

The types used by the borrow checker are somehow non-standard, in the sense
that they describe primitive types (such as \<int>) or structures
dynamically allocated in memory (collectively represented by a box), but can also refer to
a borrow or mutable borrow of a leftvalue.
This is a simplification of the types from~\cite{Pearce21}, that allow more leftvalues
in borrows. Since our simplified language has no conditionals, there is no need for
more than one leftvalue in borrows.

Moreover, a type can state that the value of a variable
has been \emph{moved}, that is, assigned
to another owner, that takes control of its ownership.
Consequently, the value exists but cannot be accessed from that variable anymore.
We write this as $\mathsf{dangling}$. This is a simplification of the
$\mathsf{dangling}(t)$ type in~\cite{Pearce21}, that embeds
the \emph{ghost} type $t$ of a value that has been moved.
This information is important to ensure that a variable, whose value has been
previously moved away, is subsequently reassigned a value compatible
with its original type $t$. However, we abstract this detail away here,
since it is related to traditional type checking and is irrelevant for
the termination of the algorithm for typing leftvalues.

\begin{definition}[Types]
  The set of \emph{types} over a context $\kappa$ is
  \begin{align*}
    \mathsf{T}_\kappa ::=&\ \mathsf{int} & \text{integer}\\
    | &\ \borrow\mathsf{w} & \text{borrow, with $\mathsf{w}\in\mathsf{T}_\kappa$}\\
    | &\ \mutborrow\mathsf{w} & \text{mutable borrow, with $\mathsf{w}\in\mathsf{T}_\kappa$}\\
    | &\ \boxtype{\mathsf{T}_\kappa} & \text{box}\\
    | &\ \mathsf{dangling} & \text{dangling}.
  \end{align*}
\end{definition}

Rust distinguishes between types with copy semantics
and types with move semantics.
Values whose type has copy semantics
are copied upon reading, while values whose type has
move semantics are \emph{moved} instead, in the sense that their original container
loses the ownership to the value. Only mutable borrows and dynamically
allocated data (hence boxes) have move semantics.

\begin{definition}[Copy and move types]\label{def:copy_move}
  Let $T\in\mathsf{T}_\kappa$. Then $T$ \emph{has move semantics}, and we write
  $\movetype(T)$, if and only if $T=\mutborrow\mathsf{w}$ or
  $T=\boxtype{T'}$ for some $T'$. In all other cases, $T$ \emph{has copy semantics},
  and we write $\copytype(T)$.
\end{definition}

Another useful notion is that of \emph{full} types. They are types that do not contain
$\mathsf{dangling}$. This notion is important because, as we will see
in Sec.~\ref{sec:borrow_checker}, only value with full type can be borrowed in Rust.

\begin{definition}[Full type]\label{def:full}
  A type $T\in\mathsf{T}_\kappa$ is \emph{full}
  if and only if $\mathsf{dangling}$ does not occur inside $T$.
  We write it as $\mathsf{full}(T)$.
\end{definition}
  
We can now define the typings, or type environments, that is,
information about the types of the variables in scope at a given program point.

\begin{definition}[Typing]\label{def:typing}
  Given a context $\kappa$, a \emph{typing} $\tau$ over $\kappa$ is
  a map from the variables in $\kappa$ to types.
\end{definition}

The types used in a typing can include borrows and mutable borrows.
The basic idea of the borrow checker is that the root of the
borrowed leftvalues (mutable or not) can only be used
in a restricted way~\cite{Pearce21}.

\begin{definition}[Read/Write Prohibited]\label{def:prohibited}
  Let $\kappa$ be a context and $\tau$ a \emph{typing} over $\kappa$.
  Then $\mathsf{w}\in\Leftvalues_\kappa$ is
  \emph{read prohibited in $\tau$},
  written as $\mathsf{readProhibited}(\mathsf{w},\tau)$,
  if $\mathsf{root}(\mathsf{w})$ occurs in a mutable borrow inside $\tau$.
  Moreover, $\mathsf{w}$ is \emph{write prohibited in $\tau$}, written
  as $\mathsf{writeProhibited}(\mathsf{w},\tau)$,
  if $\mathsf{root}(\mathsf{w})$ occurs in a borrow or in a
  mutable borrow inside $\tau$.
\end{definition}

\noindent
It follows that $\mathsf{readProhibited}(\mathsf{w},\tau)$ entails
$\mathsf{writeProhibited}(\mathsf{w},\tau)$.

A typing provides types to variables but can be used to type
leftvalues as well, as shown below. Def.~\ref{def:type} is a translation of
Def.~3.11 from~\cite{Pearce21}. It can be seen as an algorithm for typing leftvalues
and, as such, it is heavily used in the borrow checker.
The algorithm queries the typing when the leftvalue is actually a variable,
and dereferences borrows or boxes when the leftvalue contains one or more
\<*> operations, recurring in the case of borrows.
Types \<int> and \<dangling> cannot be dereferenced, hence the
algorithm fails on them.

\begin{definition}[Type of leftvalues]\label{def:type}
  Given a context $\kappa$, a typing $\tau$ over $\kappa$
  and $\mathsf{w}\in\Leftvalues_\kappa$, the partial function
  $\type(\mathsf{w},\tau)$ yields the type of $\mathsf{w}$ in $\tau$:
  \begin{align*}
    \type(x,\tau)&=\tau(x)\\
    \type(*\mathsf{w},\tau)&=\begin{cases}
    \text{undefined} & \text{if $\type(\mathsf{w},\tau)$ is undefined}\\
    \text{undefined} & \text{if $\type(\mathsf{w},\tau)=\mathsf{dangling}$}\\
    \text{undefined} & \text{if $\type(\mathsf{w},\tau)=\mathsf{int}$}\\
    \type(\mathsf{w}',\tau) & \text{if $\type(\mathsf{w},\tau)=\borrow\mathsf{w}'$}\\
    \type(\mathsf{w}',\tau) & \text{if $\type(\mathsf{w},\tau)=\mutborrow\mathsf{w}'$}\\
    T & \text{if $\type(\mathsf{w},\tau)=\boxtype{T}$.}
    \end{cases}
  \end{align*}
\end{definition}

Def.~\ref{def:type} is clearly recursive, both on the structure of $\mathsf{w}$ and
on the leftvalues contained in the borrows or mutable borrows that occur in the typing.
In general, that recursion is not well-founded. In algorithmic terms, this means
that the algorithm for computing the type of leftvalues might not terminate.
Consider for instance the typing $\{x\to\borrow\mathtt{*}x\}$:
the definition of $\type(\mathtt{*}x,\tau)$ ends in an infinite loop.
This example can be arbitrarily complicated, through the
use of more involved cycles that pass through more variables. As a consequence,
the natural question is to understand when the recursion in
Def.~\ref{def:type} is well-founded and if that is always the case when it is
used by the borrow checker of Rust.
