\section{Simplified Featherweight Rust}\label{sec:featherweight}

This section gives a formal, simplified presentation of Featherweight Rust
and of the typing rules of its borrow checker~\cite{Pearce21}.

\begin{definition}
  We assume there is a set of variables $\Vars$.
  A context $\kappa\subseteq\Vars$ is a finite set of variables in scope.
  The set $\Leftvalues_\kappa$ of \emph{leftvalues} over $\kappa$ is defined as:
  \begin{align*}
    \mathsf{w} ::= &\ x & \text{variable, with $x\in\kappa$}\\
    | &\ \mathtt{*}\mathsf{w} & \text{dereference.}
  \end{align*}
  The \emph{root} of a leftvalue is the starting variable to which the dereferences of the
  leftvalue are applied. Namely, we define
  \begin{align*}
    \mathsf{root}(x) &= x\qquad\text{if $x\in\Vars$}\\
    \mathsf{root}(\mathtt{*}\mathsf{w}) &= \mathsf{root}(\mathsf{w}).
  \end{align*}
  The set of \emph{expressions} \textsf{e} is defined as
  \begin{align*}
    \mathsf{e} ::= &\ i & \text{integer}\\
    | &\ \mathsf{w} & \text{leftvalue}\\
    | &\ \borrow\mathsf{w} & \text{borrow}\\
    | &\ \mutborrow\mathsf{w} & \text{mutable borrow}\\
    | &\ \mathtt{box}\ \mathsf{e} & \text{heap allocation.}
  \end{align*}
  The sets of \emph{terms} \textsf{t} and \emph{blocks} \textsf{b} is defined as:
  \begin{align*}
    \mathsf{t} ::= &\ \mathsf{w}=\mathsf{e} & \text{assignment}\\
    | &\ \mathtt{let\ mut}\ x=\mathsf{e} & \text{declaration, with $x\in\Vars$}\\
    | &\ \{\mathsf{t_1};\ldots;\mathsf{t_n}\} & \text{block.}
  \end{align*}
\end{definition}


The types used by the borrow checker are somehow non-standard, in the sense
that they describe primitive types (such as \<int>) or structures
dynamically allocated in memory (collectively represented by a box), but can also refer to
a borrow or mutable borrow of one or more leftvalues.
Moreover, a type can state that a value has been \emph{moved}, that is, assigned
to another owner. Consequently, the value exists but cannot be accessed.
We write this as $\mathsf{dangling}$. This is a simplification of the
$\mathsf{dangling}(t)$ type in~\cite{Pearce21}, that embeds
the \emph{ghost} type $t$ of a value that has been moved.
This information is important to ensure that a variable, whose value has been
previously moved away, is subsequently reassigned a value compatible
with its original type $t$. However, we abstract this detail away here,
since it is related to traditional type checking and is irrelevant for
the termination of the algorithm for typing leftvalues.

\begin{definition}[Types]
  The set of \emph{types} over a context $\kappa$ is
  \begin{align*}
    \mathsf{T}_\kappa ::=&\ \mathsf{int} & \text{integer}\\
    | &\ \borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} & \text{borrow}\\
    | &\ \mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} & \text{mutable borrow}\\
    | &\ \boxtype{\mathsf{T}_\kappa} & \text{box}\\
    | &\ \mathsf{dangling} & \text{dangling}
  \end{align*}
  where $n\ge 1$ and $\mathsf{w}_i\in\Leftvalues_\kappa$ for $1\le i\le n$.
  This set is ordered by $\sqsubseteq$, defined as
  \begin{align*}
    \mathsf{int}&\sqsubseteq\mathsf{int}\\
    \borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} & \sqsubseteq
    \borrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\} \quad\text{iff $\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}\subseteq\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\}$}\\
    \mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} & \sqsubseteq
    \mutborrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\} \quad\text{iff $\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}\subseteq\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\}$}\\
    \boxtype{T_1}&\sqsubseteq\boxtype{T_2} \quad\text{iff $T_1\sqsubseteq T_2$}\\
    \mathsf{dangling}&\sqsubseteq\mathsf{dangling.}
  \end{align*}
\end{definition}

\begin{lemma}
  \label{lemma:partial-order-types}
  $(\mathsf{T}_\kappa,\sqsubseteq)$ is a partially ordered set.
\end{lemma}
\begin{proof}
  We proceed by structural induction.
  \begin{itemize}
    \item (Reflexivity)
    \begin{itemize}
      \item (Base) For any type $T$ that is not a box we have
      $T\sqsubseteq T$.
      \item (Induction step) If $T\sqsubseteq T$ for a type $T$ then
      $\boxtype{T}\sqsubseteq \boxtype{T}$.
    \end{itemize}
    %
    \item (Antisymmetry) Suppose that $T_1 \sqsubseteq T_2$ and
    $T_2 \sqsubseteq T_1$.
    \begin{itemize}
      \item (Base: $T_1$ or $T_2$ is not a box)
      If $T_1$ or $T_2$ is $\mathsf{int}$, then so is the other
      because $\mathsf{int}$ can only be greater than itself, and so $T_1 = T_2$.
      Similarly if $T_1$ or $T_2$ is $\mathsf{dangling}$.
      If $T_1$ or $T_2$ is a borrow, then so is the other because
      a borrow can only precede a borrow, and so we have $T_1 = T_2$
      by antisymmetry of $\subseteq$.
      Similarly if $T_1$ or $T_2$ is a mutable borrow.
      \item (Induction step) Suppose that $T_1=\boxtype{T'_1}$ and
      $T_2=\boxtype{T'_2}$ for types $T'_1,T'_2$ such that
      $(T'_1 \sqsubseteq T'_2 \land T'_2 \sqsubseteq T'_1) \Rightarrow T'_1 = T'_2$.
      As $T_1 \sqsubseteq T_2$ and $T_2 \sqsubseteq T_1$, we have
      $T'_1 \sqsubseteq T'_2$ and $T'_2 \sqsubseteq T'_1$, so
      $T'_1 = T'_2$, hence $T_1 = T_2$.
    \end{itemize}
    %
    \item (Transitivity) Suppose that $T_1 \sqsubseteq T_2$ and $T_2 \sqsubseteq T_3$.
    \begin{itemize}
      \item (Base: $T_1$, $T_2$ or $T_3$ is not a box)
      If $T_1$, $T_2$ or $T_3$ is $\mathsf{int}$, we necessarily have
      $T_1=T_2=T_3=\mathsf{int}$ because $\mathsf{int}$ is only related to
      itself, and so $T_1\sqsubseteq T_3$. Similarly if
      $T_1$, $T_2$ or $T_3$ is $\mathsf{dangling}$.
      If $T_1$, $T_2$ or $T_3$ is a borrow, then so are the others because
      a borrow is only related to a borrow, and so we have
      $T_1\sqsubseteq T_3$ by transitivity of $\subseteq$.
      Similarly if $T_1$, $T_2$ or $T_3$ is a mutable borrow.
      \item (Induction step) Suppose that $T_1=\boxtype{T'_1}$,
      $T_2=\boxtype{T'_2}$ and $T_3=\boxtype{T'_3}$ for types
      $T'_1,T'_2,T'_3$ such that
      $(T'_1 \sqsubseteq T'_2 \land T'_2 \sqsubseteq T'_3) \Rightarrow
      T'_1 \sqsubseteq T'_3$.
      As $T_1 \sqsubseteq T_2$ and $T_2 \sqsubseteq T_3$, we have
      $T'_1 \sqsubseteq T'_2$ and $T'_2 \sqsubseteq T'_3$, so
      $T'_1 \sqsubseteq T'_3$, hence $T_1 \sqsubseteq T_3$.
    \end{itemize}
  \end{itemize}
  \qed
\end{proof}

%\begin{definition}
%  The $\sqcap$ operator over $\mathsf{T}_\kappa$ is defined as
%  \begin{align*}
%    \mathsf{int}\sqcap\mathsf{int} &= \mathsf{int}\\
%    \borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} \sqcap \borrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\} &= \borrow(\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}\cap\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\})\\
%    \mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} \sqcap \mutborrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\} &= \mutborrow(\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}\cap\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\})\\
%    (\boxtype{t_1}) \sqcap (\boxtype{t_2}) &=\boxtype{(t_1\sqcap t_2)}\quad\text{if $t_1\sqcap t_2$ is defined}\\
%    \mathsf{dangling}\sqcap\mathsf{dangling} &= \mathsf{dangling}.
%  \end{align*}
%  In all other cases, $t_1\sqcap t_2$ is undefined.
%\end{definition}

%\begin{lemma}\label{lemma:glb-type}
%  Let $I\subseteq\mathbb{N}$ and $\{t_i\}_{i\in I}\subseteq\mathsf{T}_\kappa$.
%  Then, if $\sqcap_{i\in I}t_i$ is defined, it is the greatest lower bound of $\{t_i\}_{i\in I}$.
%\end{lemma}
%\begin{proof}
%  Assume that $\mu_I = \sqcap_{i\in I}t_i$ is defined.
%  We proceed by structural induction.
%  \begin{itemize}
%    \item (Base: there is a $t_k$ which is not a box)
%    If $t_k=\mathsf{int}$ then, as $\mu_I$ is defined, for all $i\in I$
%    we have $t_i=\mathsf{int}$. Therefore, $\mu_I=\mathsf{int}$
%    and so $\mu_I$ is a lower bound of $\{t_i\}_{i\in I}$.
%    Similarly if $t_k=\mathsf{dangling}$.
%    If $t_k$ is a borrow then, for all $i\in I$, $t_i$ is a borrow, and so
%    $\mu_I$ is a borrow which results from the intersection of the sets of
%    leftvalues of all the $t_i$'s. Hence, $\mu_I$ is a lower bound of
%    $\{t_i\}_{i\in I}$.
%    Similarly if $t_k$ is a mutable borrow.
%
%    Now, suppose that $\mu'_I$ is also a lower bound of $\{t_i\}_{i\in I}$.
%    If $\mu'_I=\mathsf{int}$ then each $t_i$ is $\mathsf{int}$, so
%    $\mu_I=\mathsf{int}$ and we have $\mu'_I\sqsubseteq\mu_I$.
%    Similarly if $\mu'_I=\mathsf{dangling}$.
%    If $\mu'_I=\borrow b$, then for all $i\in I$ we have $t_i = \borrow b_i$
%    and $b \subseteq b_i$. Hence, $b \subseteq \cap_{i\in I}b_i$ and so
%    $\borrow b \sqsubseteq \borrow\cap_{i\in I}b_i$. Consequently, we have
%    $\mu'_I\sqsubseteq\mu_I$ because $\mu_I=\borrow\cap_{i\in I}b_i$ in this case.
%    Similarly if $\mu'_I$ is a mutable borrow.
%    %
%    \item (Induction step) Suppose that for all $i\in I$ we have
%    $t_i = \boxtype{t'_i}$. Since $\mu_I$ is defined, also
%    $\sqcap_{i\in I}t'_i$ is defined and, by inductive hypothesis, it must be the greatest
%    lower bound of $\{t'_i\}_{i\in I}$. Then,
%    $\mu_I = \boxtype{(\sqcap_{i\in I}t'_i)}$ is a lower bound
%    of $\{t_i\}_{i\in I}$. Suppose that $\mu'_I$ is also a lower bound
%    of $\{t_i\}_{i\in I}$. Then, $\mu'_I=\boxtype{t}$ with
%    $t\sqsubseteq t'_i$ for all $i\in I$, and so $t$ is a lower bound
%    of $\{t'_i\}_{i\in I}$; hence, we have $t\sqsubseteq \sqcap_{i\in I}t'_i$
%    because $\sqcap_{i\in I}t'_i$ is the greatest lower bound and,
%    consequently, $\mu'_I\sqsubseteq\mu_I$.
%  \end{itemize}
%  \qed
%\end{proof}

%\begin{lemma}\label{lemma:technical-type}
%  Let $t\in\mathsf{T}_\kappa$. For any $t_1,t_2\in\mathsf{T}_\kappa$,
%  if $t\sqsubseteq t_1$ and $t\sqsubseteq t_2$ then $t_1\sqcap t_2$ is defined.
%\end{lemma}
%\begin{proof}
%  We proceed by structural induction on $t$.
%  \begin{itemize}
%    \item (Base: $t$ is not a box)
%    Let $t_1,t_2\in\mathsf{T}_\kappa$ with $t\sqsubseteq t_1$ and $t\sqsubseteq t_2$.
%    If $t$ is $\mathsf{int}$ (resp. a borrow, a mutable borrow or $\mathsf{dangling}$)
%    then, necessarily, $t_1$ and $t_2$ are $\mathsf{int}$ (resp. a borrow,
%    a mutable borrow or $\mathsf{dangling}$), hence $t_1\sqcap t_2$ is defined.
%    %
%    \item (Induction step) Suppose that $t = \boxtype{t'}$.
%    Let $t_1,t_2\in\mathsf{T}_\kappa$ with $t\sqsubseteq t_1$ and $t\sqsubseteq t_2$.
%    Then, necessarily, $t_1 = \boxtype{t'_1}$ and $t_2 = \boxtype{t'_2}$
%    with $t'\sqsubseteq t'_1$ and $t'\sqsubseteq t'_2$. By induction
%    hypothesis, $t'_1\sqcap t'_2$ is defined, so
%    $(\boxtype{t'_1}) \sqcap (\boxtype{t'_2}) = t_1 \sqcap t_2$ is defined.
%    \qed
%  \end{itemize}
%\end{proof}

\begin{definition}\label{def:lub}
  The $\sqcup$ operator over $\mathsf{T}_\kappa$ is defined as
  \begin{align*}
    \mathsf{int}\sqcup\mathsf{int} &= \mathsf{int}\\
    \borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} \sqcup \borrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\} &= \borrow(\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}\cup\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\})\\
    \mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\} \sqcup \mutborrow\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\} &= \mutborrow(\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}\cup\{\mathsf{w}'_1,\ldots,\mathsf{w}'_{n'}\})\\
    (\boxtype{T_1}) \sqcup (\boxtype{T_2}) &=\boxtype{(T_1\sqcup T_2)}\quad\text{if $T_1\sqcup T_2$ is defined}\\
    \mathsf{dangling}\sqcup\mathsf{dangling} &= \mathsf{dangling}.
  \end{align*}
  In all other cases, $\sqcup$ is undefined.
\end{definition}

\begin{lemma}\label{lemma:lub-type}
  Let $I\subseteq\mathbb{N}$ and $\{T_i\}_{i\in I}\subseteq\mathsf{T}_\kappa$.
  Then, if $\sqcup_{i\in I}T_i$ is defined, it is the least upper bound of
  $\{T_i\}_{i\in I}$.
\end{lemma}
\begin{proof}
  Assume that $\nu_I = \sqcup_{i\in I}T_i$ is defined.
  We proceed by structural induction.
  \begin{itemize}
    \item (Base: there is a $T_k$ which is not a box)
    If $T_k=\mathsf{int}$ then, as $\nu_I$ is defined, for all $i\in I$
    we have $T_i=\mathsf{int}$. Therefore, $\nu_I=\mathsf{int}$
    and so $\nu_I$ is an upper bound of $\{T_i\}_{i\in I}$.
    Similarly if $T_k=\mathsf{dangling}$.
    If $T_k$ is a borrow then, for all $i\in I$, $T_i$ is a borrow, and so
    $\nu_I$ is a borrow which results from the union of the sets of
    leftvalues of all the $T_i$'s. Hence, $\nu_I$ is an upper bound of
    $\{T_i\}_{i\in I}$.
    Similarly if $T_k$ is a mutable borrow.

    Now, suppose that $\nu'_I$ is also an upper bound of $\{T_i\}_{i\in I}$.
    If $\nu'_I=\mathsf{int}$ then each $T_i$ is $\mathsf{int}$, so
    $\nu_I=\mathsf{int}$ and we have $\nu_I\sqsubseteq\nu'_I$.
    Similarly if $\nu'_I=\mathsf{dangling}$.
    If $\nu'_I=\borrow b$, then for all $i\in I$ we have $T_i = \borrow b_i$
    and $b_i\subseteq b$. Hence, $\cup_{i\in I}b_i\subseteq b$ and so
    $\borrow\cup_{i\in I}b_i\sqsubseteq\borrow b$. Consequently, we have
    $\nu_I\sqsubseteq\nu'_I$ because $\nu_I=\borrow\cup_{i\in I}b_i$ in this case.
    Similarly if $\nu'_I$ is a mutable borrow.
    %
    \item (Induction step) Suppose that for all $i\in I$ we have
    $T_i = \boxtype{T'_i}$. Since $\nu_I$ is defined, also
    $\sqcup_{i\in I}T'_i$ is defined and, by inductive hypothesis, it must be
    the least upper bound of $\{T'_i\}_{i\in I}$. Then,
    $\nu_I = \boxtype{(\sqcup_{i\in I}T'_i)}$ is an upper bound
    of $\{T_i\}_{i\in I}$. Suppose that $\nu'_I$ is also an upper bound
    of $\{T_i\}_{i\in I}$. Then, $\nu'_I=\boxtype{T}$ with
    $T'_i\sqsubseteq T$ for all $i\in I$, and so $T$ is an upper bound
    of $\{T'_i\}_{i\in I}$; hence, we have $\sqcup_{i\in I}T'_i\sqsubseteq T$
    because $\sqcup_{i\in I}T'_i$ is the least upper bound and,
    consequently, $\nu_I\sqsubseteq\nu'_I$.
  \end{itemize}
  \qed
\end{proof}

Rust distinguishes between types with copy semantics
and type with move semantics.
Values whose type has copy semantics
are copied upon reading, while values whose type has
move semantics are \emph{moved}, in the sense that their original container
loses the ownership to the value. Only mutable borrows and dynamically
allocated data (hence boxes) have move semantics.

\begin{definition}[Copy and move types]\label{def:copy_move}
  Let $T\in\mathsf{T}_\kappa$. Then $T$ \emph{has move semantics}, and we write
  $\movetype(T)$, if and only if $T=\mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}$ or
  $T=\boxtype{T'}$ for some $T'$. In all other cases, $T$ \emph{has copy semantics},
  and we write $\copytype(T)$.
\end{definition}

Another useful notion is that of \emph{full} types. They are types that do not contain
$\mathsf{dangling}$. This notion is important because, as we will see
in Sec.~\ref{sec:borrow_checker}, only value with full type can be borrowed in Rust.

\begin{definition}[Full type]\label{def:full}
  A type $T\in\mathsf{T}_\kappa$ is \emph{full}
  if and only if $\mathsf{dangling}$ does not occur inside $T$.
  We write it as $\mathsf{full}(T)$.
\end{definition}
  
We can now define the typings or type environments, that is,
information about the types of the variables in scope at a given program point.

\begin{definition}[Typing]\label{def:typing}
  Given a context $\kappa$, a \emph{typing} $\tau$ over $\kappa$ is
  a map from the variables in $\kappa$ to types.
\end{definition}

The types used in a typing can include borrows and mutable borrows.
The basic idea of the borrow checker is that the variables in
the leftvalues in those borrows (mutable or not) can only be used
in a restricted way~\cite{Pearce21}.

\begin{definition}[Read/Write Prohibited]\label{def:prohibited}
  Let $\kappa$ be a context and $\tau$ a \emph{typing} over $\kappa$.
  Then $\mathsf{w}\in\Leftvalues_\kappa$ is
  \emph{read prohibited in $\tau$},
  written as $\mathsf{readProhibited}(\mathsf{w},\tau)$,
  if $\mathsf{root}(\mathsf{w})$ occurs in a mutable borrow inside $\tau$.
  Moreover, $\mathsf{w}$ is \emph{write prohibited in $\tau$}, written
  as $\mathsf{writeProhibited}(\mathsf{w},\tau)$,
  if $\mathsf{root}(\mathsf{w})$ occurs in a borrow or in a
  mutable borrow inside $\tau$.
\end{definition}

\noindent
It follows that $\mathsf{readProhibited}(\mathsf{w},\tau)$ entails
$\mathsf{writeProhibited}(\mathsf{w},\tau)$.

A typing provides types to variables but can be used to type
leftvalues as well, as shown below. Def.~\ref{def:type} is a translation of
Def.~3.11 from~\cite{Pearce21}. It can be seen as an algorithm for typing leftvalues
and, as such, it is heavily used in the borrow checker.
The algorithm queries the typing when the leftvalue is actually a variable,
and dereferences borrows or boxes when the leftvalue contains one or more
\<*> operations, recurring in the case of borrows.
Types \<int> and \<dangling> cannot be dereferenced, hence the
algorithm fails for them.

\begin{definition}[Type of leftvalues]\label{def:type}
  Given a context $\kappa$, a typing $\tau$ over $\kappa$
  and $\mathsf{w}\in\Leftvalues_\kappa$, the partial function
  $\type(\mathsf{w},\tau)$ yields the type of $\mathsf{w}$ in $\tau$:
  \begin{align*}
    \type(x,\tau)&=\tau(x)\\
    \type(*\mathsf{w},\tau)&=\begin{cases}
    \text{undefined} & \text{if $\type(\mathsf{w},\tau)$ is undefined}\\
    \text{undefined} & \text{if $\type(\mathsf{w},\tau)=\mathsf{dangling}$}\\
    \text{undefined} & \text{if $\type(\mathsf{w},\tau)=\mathsf{int}$}\\
    \sqcup_{1\le i\le n}\type(\mathsf{w}_i,\tau) & \text{if $\type(\mathsf{w},\tau)=\borrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}$}\\
    \sqcup_{1\le i\le n}\type(\mathsf{w}_i,\tau) & \text{if $\type(\mathsf{w},\tau)=\mutborrow\{\mathsf{w}_1,\ldots,\mathsf{w}_n\}$}\\
    T & \text{if $\type(\mathsf{w},\tau)=\boxtype{T}$.}
    \end{cases}
  \end{align*}
\end{definition}

\noindent
Note that $\sqcup$ might be undefined for the cases of $\borrow$
and $\borrow\mathtt{mut}$.
As hinted in~\cite{Pearce21}, this corresponds to a situation when the program
is not well typed, in the traditional sense of type checking.

Def.~\ref{def:type} is clearly recursive, both on the structure of $\mathsf{w}$ and
on the leftvalues contained in the borrows or mutable borrows that occur in the typing.
In general, that recursion is not well-founded. In algorithmic terms, this means
that the algorithm for computing the type of leftvalues might not terminate.
Consider for instance the typing $\{x\to\borrow\{\mathtt{*}x\}\}$:
the definition of $\type(\mathtt{*}x,\tau)$ ends in an infinite loop.
This example can be arbitrarily complicated, through the
use of more involved cycles that pass through more variables. As a consequence,
the natural question is to understand when the recursion in
Def.~\ref{def:type} is well-founded and if that is always the case when it is
used by the borrow checker of Rust.
